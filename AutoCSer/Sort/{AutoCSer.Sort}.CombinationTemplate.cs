//本文件由程序自动生成,请不要自行修改
using System;
using AutoCSer;

#if NoAutoCSer
#else
#pragma warning disable

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> rangeSortDesc(this ulong[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> getRangeSortDesc(this ulong[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> rangeSortDesc(this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> getRangeSortDesc(this ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> pageSortDesc(this ulong[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, ulong> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> getPageSortDesc(this ulong[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> rangeSort(this long[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getRangeSort(this long[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> rangeSort(this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getRangeSort(this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> pageSort(this long[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getPageSort(this long[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> rangeSortDesc(this long[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getRangeSortDesc(this long[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> rangeSortDesc(this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getRangeSortDesc(this long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> pageSortDesc(this long[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> getPageSortDesc(this long[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> rangeSort(this uint[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getRangeSort(this uint[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> rangeSort(this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getRangeSort(this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> pageSort(this uint[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getPageSort(this uint[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> rangeSortDesc(this uint[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getRangeSortDesc(this uint[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> rangeSortDesc(this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getRangeSortDesc(this uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> pageSortDesc(this uint[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> getPageSortDesc(this uint[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> rangeSort(this int[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getRangeSort(this int[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> rangeSort(this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getRangeSort(this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> pageSort(this int[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getPageSort(this int[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> rangeSortDesc(this int[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getRangeSortDesc(this int[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> rangeSortDesc(this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getRangeSortDesc(this int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> pageSortDesc(this int[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> getPageSortDesc(this int[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> rangeSort(this double[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getRangeSort(this double[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> rangeSort(this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getRangeSort(this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> pageSort(this double[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getPageSort(this double[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> rangeSortDesc(this double[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getRangeSortDesc(this double[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> rangeSortDesc(this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getRangeSortDesc(this double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> pageSortDesc(this double[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> getPageSortDesc(this double[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> rangeSort(this float[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getRangeSort(this float[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> rangeSort(this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getRangeSort(this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> pageSort(this float[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getPageSort(this float[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> rangeSortDesc(this float[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getRangeSortDesc(this float[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> rangeSortDesc(this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getRangeSortDesc(this float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> pageSortDesc(this float[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> getPageSortDesc(this float[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> rangeSort(this DateTime[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getRangeSort(this DateTime[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> rangeSort(this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getRangeSort(this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSort<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSort<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> pageSort(this DateTime[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSort<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSort<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getPageSort(this DateTime[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> rangeSortDesc(this DateTime[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getRangeSortDesc(this DateTime[] array, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> rangeSortDesc(this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getRangeSortDesc(this DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getRangeSortDesc<valueType>(this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">结束位置</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getRangeSortDesc<valueType, returnType>(this valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> pageSortDesc(this DateTime[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getPageSortDesc<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] getPageSortDesc<valueType, returnType>(this valueType[] array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">分页号,从 1 开始</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> getPageSortDesc(this DateTime[] array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.length(), pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] sortDesc(this double[] array)
        {
            if (array == null) return NullValue<double>.Array;
            AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getSortDesc(this double[] array)
        {
            if (array == null) return NullValue<double>.Array;
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, double> getKey)
        {
            if (array != null)
            {
                if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return NullValue<valueType>.Array;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] sort(this float[] array)
        {
            if (array == null) return NullValue<float>.Array;
            AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getSort(this float[] array)
        {
            if (array == null) return NullValue<float>.Array;
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, float> getKey)
        {
            if (array != null)
            {
                if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return NullValue<valueType>.Array;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] sortDesc(this float[] array)
        {
            if (array == null) return NullValue<float>.Array;
            AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getSortDesc(this float[] array)
        {
            if (array == null) return NullValue<float>.Array;
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, float> getKey)
        {
            if (array != null)
            {
                if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey);
                if (array.Length != 0) return new valueType[] { array[0] };
            }
            return NullValue<valueType>.Array;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void SortDesc(ulong[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.SortDesc(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ulong[] sortDesc(this ulong[] array)
        {
            if (array == null) return NullValue<ulong>.Array;
            if (array.Length > 1) SortDesc(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> sortDesc(this ulong[] array, int index, int count)
        {
            if (array == null) return default(SubArray<ulong>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) SortDesc(array, index, count);
            return new SubArray<ulong> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static ulong[] GetSortDesc(ulong[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSortDesc(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ulong[] getSortDesc(this ulong[] array)
        {
            if (array == null) return NullValue<ulong>.Array;
            return array.Length > 1 ? GetSortDesc(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ulong[] getSortDesc(this ulong[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<ulong>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new ulong[] { array[index] };
            return GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSortDesc<valueType>(valueType[] array, Func<valueType, ulong> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.ULongSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.ULongSortIndex* indexFixed = (AutoCSer.Algorithm.ULongSortIndex*)data.Data;
                    AutoCSer.Algorithm.ULongSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.SortDesc(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.ULongSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, ulong> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSortDesc(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, ulong> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSortDesc(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Sort(long[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.Sort(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] sort(this long[] array)
        {
            if (array == null) return NullValue<long>.Array;
            if (array.Length > 1) Sort(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> sort(this long[] array, int index, int count)
        {
            if (array == null) return default(SubArray<long>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) Sort(array, index, count);
            return new SubArray<long> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static long[] GetSort(long[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSort(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getSort(this long[] array)
        {
            if (array == null) return NullValue<long>.Array;
            return array.Length > 1 ? GetSort(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getSort(this long[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<long>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new long[] { array[index] };
            return GetSort(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSort<valueType>(valueType[] array, Func<valueType, long> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.LongSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.LongSortIndex* indexFixed = (AutoCSer.Algorithm.LongSortIndex*)data.Data;
                    AutoCSer.Algorithm.LongSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.Sort(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.LongSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, long> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSort(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, long> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSort(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void SortDesc(long[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.SortDesc(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] sortDesc(this long[] array)
        {
            if (array == null) return NullValue<long>.Array;
            if (array.Length > 1) SortDesc(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> sortDesc(this long[] array, int index, int count)
        {
            if (array == null) return default(SubArray<long>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) SortDesc(array, index, count);
            return new SubArray<long> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static long[] GetSortDesc(long[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSortDesc(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getSortDesc(this long[] array)
        {
            if (array == null) return NullValue<long>.Array;
            return array.Length > 1 ? GetSortDesc(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getSortDesc(this long[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<long>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new long[] { array[index] };
            return GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSortDesc<valueType>(valueType[] array, Func<valueType, long> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.LongSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.LongSortIndex* indexFixed = (AutoCSer.Algorithm.LongSortIndex*)data.Data;
                    AutoCSer.Algorithm.LongSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.SortDesc(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.LongSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, long> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSortDesc(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, long> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSortDesc(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Sort(uint[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.Sort(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] sort(this uint[] array)
        {
            if (array == null) return NullValue<uint>.Array;
            if (array.Length > 1) Sort(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> sort(this uint[] array, int index, int count)
        {
            if (array == null) return default(SubArray<uint>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) Sort(array, index, count);
            return new SubArray<uint> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static uint[] GetSort(uint[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSort(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getSort(this uint[] array)
        {
            if (array == null) return NullValue<uint>.Array;
            return array.Length > 1 ? GetSort(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getSort(this uint[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<uint>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new uint[] { array[index] };
            return GetSort(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSort<valueType>(valueType[] array, Func<valueType, uint> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.UIntSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.UIntSortIndex* indexFixed = (AutoCSer.Algorithm.UIntSortIndex*)data.Data;
                    AutoCSer.Algorithm.UIntSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.Sort(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.UIntSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, uint> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSort(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, uint> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSort(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void SortDesc(uint[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.SortDesc(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] sortDesc(this uint[] array)
        {
            if (array == null) return NullValue<uint>.Array;
            if (array.Length > 1) SortDesc(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> sortDesc(this uint[] array, int index, int count)
        {
            if (array == null) return default(SubArray<uint>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) SortDesc(array, index, count);
            return new SubArray<uint> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static uint[] GetSortDesc(uint[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSortDesc(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getSortDesc(this uint[] array)
        {
            if (array == null) return NullValue<uint>.Array;
            return array.Length > 1 ? GetSortDesc(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getSortDesc(this uint[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<uint>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new uint[] { array[index] };
            return GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSortDesc<valueType>(valueType[] array, Func<valueType, uint> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.UIntSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.UIntSortIndex* indexFixed = (AutoCSer.Algorithm.UIntSortIndex*)data.Data;
                    AutoCSer.Algorithm.UIntSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.SortDesc(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.UIntSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, uint> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSortDesc(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, uint> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSortDesc(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Sort(int[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.Sort(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] sort(this int[] array)
        {
            if (array == null) return NullValue<int>.Array;
            if (array.Length > 1) Sort(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> sort(this int[] array, int index, int count)
        {
            if (array == null) return default(SubArray<int>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) Sort(array, index, count);
            return new SubArray<int> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static int[] GetSort(int[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSort(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getSort(this int[] array)
        {
            if (array == null) return NullValue<int>.Array;
            return array.Length > 1 ? GetSort(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getSort(this int[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<int>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new int[] { array[index] };
            return GetSort(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSort<valueType>(valueType[] array, Func<valueType, int> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.IntSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.IntSortIndex* indexFixed = (AutoCSer.Algorithm.IntSortIndex*)data.Data;
                    AutoCSer.Algorithm.IntSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.Sort(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.IntSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, int> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSort(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, int> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSort(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void SortDesc(int[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.SortDesc(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] sortDesc(this int[] array)
        {
            if (array == null) return NullValue<int>.Array;
            if (array.Length > 1) SortDesc(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> sortDesc(this int[] array, int index, int count)
        {
            if (array == null) return default(SubArray<int>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) SortDesc(array, index, count);
            return new SubArray<int> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static int[] GetSortDesc(int[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSortDesc(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getSortDesc(this int[] array)
        {
            if (array == null) return NullValue<int>.Array;
            return array.Length > 1 ? GetSortDesc(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getSortDesc(this int[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<int>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new int[] { array[index] };
            return GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSortDesc<valueType>(valueType[] array, Func<valueType, int> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.IntSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.IntSortIndex* indexFixed = (AutoCSer.Algorithm.IntSortIndex*)data.Data;
                    AutoCSer.Algorithm.IntSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.SortDesc(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.IntSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, int> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSortDesc(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, int> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSortDesc(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Sort(DateTime[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.Sort(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] sort(this DateTime[] array)
        {
            if (array == null) return NullValue<DateTime>.Array;
            if (array.Length > 1) Sort(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> sort(this DateTime[] array, int index, int count)
        {
            if (array == null) return default(SubArray<DateTime>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) Sort(array, index, count);
            return new SubArray<DateTime> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static DateTime[] GetSort(DateTime[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSort(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getSort(this DateTime[] array)
        {
            if (array == null) return NullValue<DateTime>.Array;
            return array.Length > 1 ? GetSort(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getSort(this DateTime[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<DateTime>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new DateTime[] { array[index] };
            return GetSort(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSort<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.DateTimeSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.DateTimeSortIndex* indexFixed = (AutoCSer.Algorithm.DateTimeSortIndex*)data.Data;
                    AutoCSer.Algorithm.DateTimeSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.Sort(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.DateTimeSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, DateTime> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSort(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSort<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSort(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySort
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void SortDesc(DateTime[] array, int index, int count)
        {
            if (array.Length >= AutoCSer.Algorithm.RadixSort.SortSize64) AutoCSer.Algorithm.RadixSort.SortDesc(array, index, count);
            else AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] sortDesc(this DateTime[] array)
        {
            if (array == null) return NullValue<DateTime>.Array;
            if (array.Length > 1) SortDesc(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> sortDesc(this DateTime[] array, int index, int count)
        {
            if (array == null) return default(SubArray<DateTime>);
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count > 1) SortDesc(array, index, count);
            return new SubArray<DateTime> { Array = array, Start = index, Length = count };
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static DateTime[] GetSortDesc(DateTime[] array, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64) return AutoCSer.Algorithm.RadixSort.GetSortDesc(array, index, count);
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getSortDesc(this DateTime[] array)
        {
            if (array == null) return NullValue<DateTime>.Array;
            return array.Length > 1 ? GetSortDesc(array, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getSortDesc(this DateTime[] array, int index, int count)
        {
            if (array == null || count == 0) return NullValue<DateTime>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new DateTime[] { array[index] };
            return GetSortDesc(array, index, count);
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] GetSortDesc<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int index, int count)
        {
            if (count >= AutoCSer.Algorithm.RadixSort.SortSize64)
            {
                int size = (count << 1) * sizeof(AutoCSer.Algorithm.DateTimeSortIndex);
                UnmanagedPool pool = AutoCSer.Algorithm.RadixSort.GetUnmanagedPool(size);
                Pointer.Size data = pool.GetSize(size);
                try
                {
                    AutoCSer.Algorithm.DateTimeSortIndex* indexFixed = (AutoCSer.Algorithm.DateTimeSortIndex*)data.Data;
                    AutoCSer.Algorithm.DateTimeSortIndex.Create(indexFixed, array, getKey, index, count);
                    AutoCSer.Algorithm.RadixSort.SortDesc(indexFixed, indexFixed + count, count);
                    return AutoCSer.Algorithm.DateTimeSortIndex.Create(indexFixed, array, count);
                }
                finally { pool.PushOnly(ref data); }
            }
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array, getKey, index, count);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, DateTime> getKey)
        {
            if (array == null) return NullValue<valueType>.Array;
            return array.Length > 1 ? GetSortDesc(array, getKey, 0, array.Length) : array.copy();
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] getSortDesc<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, int index, int count)
        {
            if (array == null || count == 0) return NullValue<valueType>.Array;
            if (index < 0) throw new IndexOutOfRangeException("index[" + index.toString() + "] < 0");
            if (index + count > array.Length) throw new IndexOutOfRangeException("index[" + index.toString() + "] + count[" + count.toString() + "] > array.Length[" + array.Length.toString() + "]");
            if (count == 1) return new valueType[] { array[index] };
            return GetSortDesc(array, getKey, index, count);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static long[] getArray(this System.Collections.Generic.ICollection<long> values)
        {
            if (values.count() == 0) return NullValue<long>.Array;
            long[] newValues = new long[values.Count];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                foreach (long value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static long[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, long> getValue)
        {
            if (values.count() == 0) return NullValue<long>.Array;
            long[] newValues = new long[values.Count];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<long> getFind(this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<long>);
            long[] newValues = new long[values.Count];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                foreach (long value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<long> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<long> getFind(this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            if (values == null) return default(LeftArray<long>);
            long[] newValues = new long[values.Count];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                foreach (long value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<long> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getFindArray(this System.Collections.Generic.ICollection<long> values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getFindArray(this System.Collections.ICollection values, Func<long, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static uint[] getArray(this System.Collections.Generic.ICollection<uint> values)
        {
            if (values.count() == 0) return NullValue<uint>.Array;
            uint[] newValues = new uint[values.Count];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                foreach (uint value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static uint[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, uint> getValue)
        {
            if (values.count() == 0) return NullValue<uint>.Array;
            uint[] newValues = new uint[values.Count];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<uint> getFind(this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<uint>);
            uint[] newValues = new uint[values.Count];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                foreach (uint value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<uint> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<uint> getFind(this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            if (values == null) return default(LeftArray<uint>);
            uint[] newValues = new uint[values.Count];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                foreach (uint value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<uint> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getFindArray(this System.Collections.Generic.ICollection<uint> values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getFindArray(this System.Collections.ICollection values, Func<uint, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static int[] getArray(this System.Collections.Generic.ICollection<int> values)
        {
            if (values.count() == 0) return NullValue<int>.Array;
            int[] newValues = new int[values.Count];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                foreach (int value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static int[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, int> getValue)
        {
            if (values.count() == 0) return NullValue<int>.Array;
            int[] newValues = new int[values.Count];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<int> getFind(this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<int>);
            int[] newValues = new int[values.Count];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                foreach (int value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<int> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<int> getFind(this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            if (values == null) return default(LeftArray<int>);
            int[] newValues = new int[values.Count];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                foreach (int value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<int> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getFindArray(this System.Collections.Generic.ICollection<int> values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getFindArray(this System.Collections.ICollection values, Func<int, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static ushort[] getArray(this System.Collections.Generic.ICollection<ushort> values)
        {
            if (values.count() == 0) return NullValue<ushort>.Array;
            ushort[] newValues = new ushort[values.Count];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                foreach (ushort value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static ushort[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, ushort> getValue)
        {
            if (values.count() == 0) return NullValue<ushort>.Array;
            ushort[] newValues = new ushort[values.Count];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<ushort> getFind(this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<ushort>);
            ushort[] newValues = new ushort[values.Count];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                foreach (ushort value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<ushort> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<ushort> getFind(this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            if (values == null) return default(LeftArray<ushort>);
            ushort[] newValues = new ushort[values.Count];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                foreach (ushort value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<ushort> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] getFindArray(this System.Collections.Generic.ICollection<ushort> values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] getFindArray(this System.Collections.ICollection values, Func<ushort, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static short[] getArray(this System.Collections.Generic.ICollection<short> values)
        {
            if (values.count() == 0) return NullValue<short>.Array;
            short[] newValues = new short[values.Count];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                foreach (short value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static short[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, short> getValue)
        {
            if (values.count() == 0) return NullValue<short>.Array;
            short[] newValues = new short[values.Count];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<short> getFind(this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<short>);
            short[] newValues = new short[values.Count];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                foreach (short value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<short> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<short> getFind(this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            if (values == null) return default(LeftArray<short>);
            short[] newValues = new short[values.Count];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                foreach (short value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<short> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] getFindArray(this System.Collections.Generic.ICollection<short> values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] getFindArray(this System.Collections.ICollection values, Func<short, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static byte[] getArray(this System.Collections.Generic.ICollection<byte> values)
        {
            if (values.count() == 0) return NullValue<byte>.Array;
            byte[] newValues = new byte[values.Count];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                foreach (byte value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static byte[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, byte> getValue)
        {
            if (values.count() == 0) return NullValue<byte>.Array;
            byte[] newValues = new byte[values.Count];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<byte> getFind(this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<byte>);
            byte[] newValues = new byte[values.Count];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                foreach (byte value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<byte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<byte> getFind(this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            if (values == null) return default(LeftArray<byte>);
            byte[] newValues = new byte[values.Count];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                foreach (byte value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<byte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] getFindArray(this System.Collections.Generic.ICollection<byte> values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] getFindArray(this System.Collections.ICollection values, Func<byte, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static sbyte[] getArray(this System.Collections.Generic.ICollection<sbyte> values)
        {
            if (values.count() == 0) return NullValue<sbyte>.Array;
            sbyte[] newValues = new sbyte[values.Count];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                foreach (sbyte value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static sbyte[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, sbyte> getValue)
        {
            if (values.count() == 0) return NullValue<sbyte>.Array;
            sbyte[] newValues = new sbyte[values.Count];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<sbyte> getFind(this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<sbyte>);
            sbyte[] newValues = new sbyte[values.Count];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                foreach (sbyte value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<sbyte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<sbyte> getFind(this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            if (values == null) return default(LeftArray<sbyte>);
            sbyte[] newValues = new sbyte[values.Count];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                foreach (sbyte value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<sbyte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] getFindArray(this System.Collections.Generic.ICollection<sbyte> values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] getFindArray(this System.Collections.ICollection values, Func<sbyte, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static double[] getArray(this System.Collections.Generic.ICollection<double> values)
        {
            if (values.count() == 0) return NullValue<double>.Array;
            double[] newValues = new double[values.Count];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                foreach (double value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static double[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, double> getValue)
        {
            if (values.count() == 0) return NullValue<double>.Array;
            double[] newValues = new double[values.Count];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<double> getFind(this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<double>);
            double[] newValues = new double[values.Count];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                foreach (double value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<double> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<double> getFind(this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            if (values == null) return default(LeftArray<double>);
            double[] newValues = new double[values.Count];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                foreach (double value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<double> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getFindArray(this System.Collections.Generic.ICollection<double> values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getFindArray(this System.Collections.ICollection values, Func<double, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static float[] getArray(this System.Collections.Generic.ICollection<float> values)
        {
            if (values.count() == 0) return NullValue<float>.Array;
            float[] newValues = new float[values.Count];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                foreach (float value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static float[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, float> getValue)
        {
            if (values.count() == 0) return NullValue<float>.Array;
            float[] newValues = new float[values.Count];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<float> getFind(this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<float>);
            float[] newValues = new float[values.Count];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                foreach (float value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<float> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<float> getFind(this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            if (values == null) return default(LeftArray<float>);
            float[] newValues = new float[values.Count];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                foreach (float value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<float> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getFindArray(this System.Collections.Generic.ICollection<float> values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getFindArray(this System.Collections.ICollection values, Func<float, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static char[] getArray(this System.Collections.Generic.ICollection<char> values)
        {
            if (values.count() == 0) return NullValue<char>.Array;
            char[] newValues = new char[values.Count];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                foreach (char value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static char[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, char> getValue)
        {
            if (values.count() == 0) return NullValue<char>.Array;
            char[] newValues = new char[values.Count];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<char> getFind(this System.Collections.Generic.ICollection<char> values, Func<char, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<char>);
            char[] newValues = new char[values.Count];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                foreach (char value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<char> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<char> getFind(this System.Collections.ICollection values, Func<char, bool> isValue)
        {
            if (values == null) return default(LeftArray<char>);
            char[] newValues = new char[values.Count];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                foreach (char value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<char> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] getFindArray(this System.Collections.Generic.ICollection<char> values, Func<char, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] getFindArray(this System.Collections.ICollection values, Func<char, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 集合相关扩展
    /// </summary>
    public static unsafe partial class Collection
    {
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <param name="values">值集合</param>
        /// <returns>数组</returns>
        public static DateTime[] getArray(this System.Collections.Generic.ICollection<DateTime> values)
        {
            if (values.count() == 0) return NullValue<DateTime>.Array;
            DateTime[] newValues = new DateTime[values.Count];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                foreach (DateTime value in values) *write++ = value;
            }
            return newValues;
        }
        /// <summary>
        /// 根据集合内容返回数组
        /// </summary>
        /// <typeparam name="valueType">枚举值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getValue">获取数组值的委托</param>
        /// <returns>数组</returns>
        public static DateTime[] getArray<valueType>(this System.Collections.Generic.ICollection<valueType> values, Func<valueType, DateTime> getValue)
        {
            if (values.count() == 0) return NullValue<DateTime>.Array;
            DateTime[] newValues = new DateTime[values.Count];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                foreach (valueType value in values) *write++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<DateTime> getFind(this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            if (values.count() == 0) return default(LeftArray<DateTime>);
            DateTime[] newValues = new DateTime[values.Count];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                foreach (DateTime value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<DateTime> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        public static LeftArray<DateTime> getFind(this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            if (values == null) return default(LeftArray<DateTime>);
            DateTime[] newValues = new DateTime[values.Count];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                foreach (DateTime value in values)
                {
                    if (isValue(value)) *write++ = value;
                }
                return new LeftArray<DateTime> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getFindArray(this System.Collections.Generic.ICollection<DateTime> values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
        /// <summary>
        /// 查找符合条件的记录集合
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="isValue">判断记录是否符合条件的委托</param>
        /// <returns>符合条件的记录集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getFindArray(this System.Collections.ICollection values, Func<DateTime, bool> isValue)
        {
            return values.getFind(isValue).ToArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long max(this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, out long value)
        {
            if (values != null)
            {
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<long> values, out long value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = long.MinValue;
                foreach (long nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long min(this System.Collections.Generic.IEnumerable<long> values, long nullValue)
        {
            long value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                long key = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, out long value)
        {
            if (values != null)
            {
                int count = -1;
                value = long.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        long nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = long.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint max(this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, out uint value)
        {
            if (values != null)
            {
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<uint> values, out uint value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = uint.MinValue;
                foreach (uint nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint min(this System.Collections.Generic.IEnumerable<uint> values, uint nullValue)
        {
            uint value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                uint key = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, out uint value)
        {
            if (values != null)
            {
                int count = -1;
                value = uint.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        uint nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = uint.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int max(this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, out int value)
        {
            if (values != null)
            {
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<int> values, out int value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = int.MinValue;
                foreach (int nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int min(this System.Collections.Generic.IEnumerable<int> values, int nullValue)
        {
            int value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                int key = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, out int value)
        {
            if (values != null)
            {
                int count = -1;
                value = int.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        int nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = int.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort max(this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, out ushort value)
        {
            if (values != null)
            {
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<ushort> values, out ushort value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = ushort.MinValue;
                foreach (ushort nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort min(this System.Collections.Generic.IEnumerable<ushort> values, ushort nullValue)
        {
            ushort value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                ushort key = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, out ushort value)
        {
            if (values != null)
            {
                int count = -1;
                value = ushort.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        ushort nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = ushort.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short max(this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, out short value)
        {
            if (values != null)
            {
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<short> values, out short value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = short.MinValue;
                foreach (short nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short min(this System.Collections.Generic.IEnumerable<short> values, short nullValue)
        {
            short value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                short key = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, out short value)
        {
            if (values != null)
            {
                int count = -1;
                value = short.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        short nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = short.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte max(this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, out byte value)
        {
            if (values != null)
            {
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<byte> values, out byte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = byte.MinValue;
                foreach (byte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte min(this System.Collections.Generic.IEnumerable<byte> values, byte nullValue)
        {
            byte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                byte key = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, out byte value)
        {
            if (values != null)
            {
                int count = -1;
                value = byte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        byte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = byte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte max(this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (values != null)
            {
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<sbyte> values, out sbyte value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = sbyte.MinValue;
                foreach (sbyte nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte min(this System.Collections.Generic.IEnumerable<sbyte> values, sbyte nullValue)
        {
            sbyte value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                sbyte key = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (values != null)
            {
                int count = -1;
                value = sbyte.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        sbyte nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = sbyte.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double max(this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, out double value)
        {
            if (values != null)
            {
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<double> values, out double value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = double.MinValue;
                foreach (double nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double min(this System.Collections.Generic.IEnumerable<double> values, double nullValue)
        {
            double value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                double key = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, out double value)
        {
            if (values != null)
            {
                int count = -1;
                value = double.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        double nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = double.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float max(this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, out float value)
        {
            if (values != null)
            {
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<float> values, out float value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = float.MinValue;
                foreach (float nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float min(this System.Collections.Generic.IEnumerable<float> values, float nullValue)
        {
            float value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                float key = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, out float value)
        {
            if (values != null)
            {
                int count = -1;
                value = float.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        float nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = float.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<char> values, out char value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = char.MinValue;
                foreach (char nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = char.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char max(this System.Collections.Generic.IEnumerable<char> values, char nullValue)
        {
            char value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                char key = char.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        char nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, out char value)
        {
            if (values != null)
            {
                int count = -1;
                value = char.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        char nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = char.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<char> values, out char value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = char.MinValue;
                foreach (char nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = char.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char min(this System.Collections.Generic.IEnumerable<char> values, char nullValue)
        {
            char value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                char key = char.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        char nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, out char value)
        {
            if (values != null)
            {
                int count = -1;
                value = char.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        char nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = char.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 可枚举相关扩展
    /// </summary>
    public static partial class Enumerable
    {
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue > value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime max(this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return max(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (values != null)
            {
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey > value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最大值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime maxKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this System.Collections.Generic.IEnumerable<DateTime> values, out DateTime value)
        {
            if (values != null)
            {
                bool isValue = false;
                value = DateTime.MinValue;
                foreach (DateTime nextValue in values)
                {
                    if (nextValue < value) value = nextValue;
                    isValue = true;
                }
                if (isValue) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <param name="values">值集合</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime min(this System.Collections.Generic.IEnumerable<DateTime> values, DateTime nullValue)
        {
            DateTime value;
            return min(values, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, out valueType value)
        {
            value = default(valueType);
            if (values != null)
            {
                int count = -1;
                DateTime key = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) key = getKey(value = nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < key)
                        {
                            value = nextValue;
                            key = nextKey;
                        }
                    }
                }
                if (count != -1) return true;
            }
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(values, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (values != null)
            {
                int count = -1;
                value = DateTime.MinValue;
                foreach (valueType nextValue in values)
                {
                    if (++count == 0) value = getKey(nextValue);
                    else
                    {
                        DateTime nextKey = getKey(nextValue);
                        if (nextKey < value) value = nextKey;
                    }
                }
                if (count != -1) return true;
            }
            value = DateTime.MinValue;
            return false;
        }
        /// <summary>
        /// 获取最小值记录
        /// </summary>
        /// <typeparam name="valueType">值类型</typeparam>
        /// <param name="values">值集合</param>
        /// <param name="getKey">获取排序键的委托</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime minKey<valueType>(this System.Collections.Generic.IEnumerable<valueType> values, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(values, getKey, out value) ? value : nullValue;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(long[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (long* valueFixed = array)
                {
                    for (long* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (long* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(long));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(long[] array, int index, int length)
        {
            fixed (long* valueFixed = array)
            {
                for (long* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    long value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] reverse(this long[] array)
        {
            if (array == null) return NullValue<long>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static long[] GetReverse(long[] array, int index, int length)
        {
            long[] newValues = new long[length];
            fixed (long* valueFixed = array, newValueFixed = newValues)
            {
                for (long* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getReverse(this long[] array)
        {
            if (array == null || array.Length == 0) return NullValue<long>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static long* IndexOf(long* valueFixed, int length, long value)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this long[] array, long value)
        {
            if (array != null)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static long* IndexOf(long* valueFixed, int length, Func<long, bool> isValue)
        {
            for (long* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this long[] array, Func<long, bool> isValue)
        {
            if (array != null)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public static long firstOrDefault(this long[] array, Func<long, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (long* valueFixed = array)
                {
                    long* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this long[] array, Func<long, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (long* valueFixed = array)
            {
                for (long* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static long[] replaceFirst(this long[] array, long value, Func<long, bool> isValue)
        {
            if (array == null) return NullValue<long>.Array;
            fixed (long* valueFixed = array)
            {
                long* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static long[] getArray<valueType>(this valueType[] array, Func<valueType, long> getValue)
        {
            if (array.isEmpty()) return NullValue<long>.Array;
            long[] newValues = new long[array.Length];
            fixed (long* newValueFixed = newValues)
            {
                long* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<long> GetFind(this long[] array, int index, int length, Func<long, bool> isValue)
        {
            long[] newValues = new long[length < sizeof(int) ? sizeof(int) : length];
            fixed (long* newValueFixed = newValues, valueFixed = array)
            {
                long* write = newValueFixed;
                for (long* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<long> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> getFind(this long[] array, Func<long, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<long>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static long[] getFindArray(this long[] array, Func<long, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<long>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static long[] GetFindArray(long[] array, int index, int count, Func<long, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (long* valueFixed = array)
            {
                long* startFixed = valueFixed + index, end = startFixed + count;
                for (long* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    long[] newValues = new long[length];
                    fixed (long* newValueFixed = newValues)
                    {
                        long* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<long>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this long[] array, out long value)
        {
            if (array.isEmpty())
            {
                value = long.MinValue;
                return false;
            }
            fixed (long* valueFixed = array)
            {
                value = *valueFixed;
                for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long max(this long[] array, long nullValue)
        {
            long value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, long> getKey, out long value)
        {
            if (array.isEmpty())
            {
                value = long.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                long nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long maxKey<valueType>(this valueType[] array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, long> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            long maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                long nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this long[] array, out long value)
        {
            if (array.isEmpty())
            {
                value = long.MaxValue;
                return false;
            }
            fixed (long* valueFixed = array)
            {
                value = *valueFixed;
                for (long* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long min(this long[] array, long nullValue)
        {
            long value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, long> getKey, out long value)
        {
            if (array.isEmpty())
            {
                value = long.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                long nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long minKey<valueType>(this valueType[] array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, long> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            long minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                long nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(uint[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (uint* valueFixed = array)
                {
                    for (uint* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (uint* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(uint));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(uint[] array, int index, int length)
        {
            fixed (uint* valueFixed = array)
            {
                for (uint* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    uint value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] reverse(this uint[] array)
        {
            if (array == null) return NullValue<uint>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static uint[] GetReverse(uint[] array, int index, int length)
        {
            uint[] newValues = new uint[length];
            fixed (uint* valueFixed = array, newValueFixed = newValues)
            {
                for (uint* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getReverse(this uint[] array)
        {
            if (array == null || array.Length == 0) return NullValue<uint>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static uint* IndexOf(uint* valueFixed, int length, uint value)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this uint[] array, uint value)
        {
            if (array != null)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static uint* IndexOf(uint* valueFixed, int length, Func<uint, bool> isValue)
        {
            for (uint* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this uint[] array, Func<uint, bool> isValue)
        {
            if (array != null)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public static uint firstOrDefault(this uint[] array, Func<uint, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (uint* valueFixed = array)
                {
                    uint* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this uint[] array, Func<uint, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (uint* valueFixed = array)
            {
                for (uint* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static uint[] replaceFirst(this uint[] array, uint value, Func<uint, bool> isValue)
        {
            if (array == null) return NullValue<uint>.Array;
            fixed (uint* valueFixed = array)
            {
                uint* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static uint[] getArray<valueType>(this valueType[] array, Func<valueType, uint> getValue)
        {
            if (array.isEmpty()) return NullValue<uint>.Array;
            uint[] newValues = new uint[array.Length];
            fixed (uint* newValueFixed = newValues)
            {
                uint* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<uint> GetFind(this uint[] array, int index, int length, Func<uint, bool> isValue)
        {
            uint[] newValues = new uint[length < sizeof(int) ? sizeof(int) : length];
            fixed (uint* newValueFixed = newValues, valueFixed = array)
            {
                uint* write = newValueFixed;
                for (uint* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<uint> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> getFind(this uint[] array, Func<uint, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<uint>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static uint[] getFindArray(this uint[] array, Func<uint, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<uint>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static uint[] GetFindArray(uint[] array, int index, int count, Func<uint, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (uint* valueFixed = array)
            {
                uint* startFixed = valueFixed + index, end = startFixed + count;
                for (uint* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    uint[] newValues = new uint[length];
                    fixed (uint* newValueFixed = newValues)
                    {
                        uint* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<uint>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this uint[] array, out uint value)
        {
            if (array.isEmpty())
            {
                value = uint.MinValue;
                return false;
            }
            fixed (uint* valueFixed = array)
            {
                value = *valueFixed;
                for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint max(this uint[] array, uint nullValue)
        {
            uint value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, uint> getKey, out uint value)
        {
            if (array.isEmpty())
            {
                value = uint.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                uint nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint maxKey<valueType>(this valueType[] array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, uint> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            uint maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                uint nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this uint[] array, out uint value)
        {
            if (array.isEmpty())
            {
                value = uint.MaxValue;
                return false;
            }
            fixed (uint* valueFixed = array)
            {
                value = *valueFixed;
                for (uint* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint min(this uint[] array, uint nullValue)
        {
            uint value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, uint> getKey, out uint value)
        {
            if (array.isEmpty())
            {
                value = uint.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                uint nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint minKey<valueType>(this valueType[] array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, uint> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            uint minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                uint nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(int[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (int* valueFixed = array)
                {
                    for (int* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (int* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(int));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(int[] array, int index, int length)
        {
            fixed (int* valueFixed = array)
            {
                for (int* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    int value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] reverse(this int[] array)
        {
            if (array == null) return NullValue<int>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static int[] GetReverse(int[] array, int index, int length)
        {
            int[] newValues = new int[length];
            fixed (int* valueFixed = array, newValueFixed = newValues)
            {
                for (int* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getReverse(this int[] array)
        {
            if (array == null || array.Length == 0) return NullValue<int>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static int* IndexOf(int* valueFixed, int length, int value)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this int[] array, int value)
        {
            if (array != null)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static int* IndexOf(int* valueFixed, int length, Func<int, bool> isValue)
        {
            for (int* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this int[] array, Func<int, bool> isValue)
        {
            if (array != null)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public static int firstOrDefault(this int[] array, Func<int, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (int* valueFixed = array)
                {
                    int* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this int[] array, Func<int, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (int* valueFixed = array)
            {
                for (int* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static int[] replaceFirst(this int[] array, int value, Func<int, bool> isValue)
        {
            if (array == null) return NullValue<int>.Array;
            fixed (int* valueFixed = array)
            {
                int* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static int[] getArray<valueType>(this valueType[] array, Func<valueType, int> getValue)
        {
            if (array.isEmpty()) return NullValue<int>.Array;
            int[] newValues = new int[array.Length];
            fixed (int* newValueFixed = newValues)
            {
                int* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<int> GetFind(this int[] array, int index, int length, Func<int, bool> isValue)
        {
            int[] newValues = new int[length < sizeof(int) ? sizeof(int) : length];
            fixed (int* newValueFixed = newValues, valueFixed = array)
            {
                int* write = newValueFixed;
                for (int* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<int> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> getFind(this int[] array, Func<int, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<int>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static int[] getFindArray(this int[] array, Func<int, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<int>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static int[] GetFindArray(int[] array, int index, int count, Func<int, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (int* valueFixed = array)
            {
                int* startFixed = valueFixed + index, end = startFixed + count;
                for (int* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    int[] newValues = new int[length];
                    fixed (int* newValueFixed = newValues)
                    {
                        int* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<int>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this int[] array, out int value)
        {
            if (array.isEmpty())
            {
                value = int.MinValue;
                return false;
            }
            fixed (int* valueFixed = array)
            {
                value = *valueFixed;
                for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int max(this int[] array, int nullValue)
        {
            int value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, int> getKey, out int value)
        {
            if (array.isEmpty())
            {
                value = int.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                int nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int maxKey<valueType>(this valueType[] array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, int> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            int maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                int nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this int[] array, out int value)
        {
            if (array.isEmpty())
            {
                value = int.MaxValue;
                return false;
            }
            fixed (int* valueFixed = array)
            {
                value = *valueFixed;
                for (int* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int min(this int[] array, int nullValue)
        {
            int value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, int> getKey, out int value)
        {
            if (array.isEmpty())
            {
                value = int.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                int nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int minKey<valueType>(this valueType[] array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, int> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            int minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                int nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(ushort[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (ushort* valueFixed = array)
                {
                    for (ushort* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (ushort* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(ushort));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(ushort[] array, int index, int length)
        {
            fixed (ushort* valueFixed = array)
            {
                for (ushort* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    ushort value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] reverse(this ushort[] array)
        {
            if (array == null) return NullValue<ushort>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static ushort[] GetReverse(ushort[] array, int index, int length)
        {
            ushort[] newValues = new ushort[length];
            fixed (ushort* valueFixed = array, newValueFixed = newValues)
            {
                for (ushort* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] getReverse(this ushort[] array)
        {
            if (array == null || array.Length == 0) return NullValue<ushort>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static ushort* IndexOf(ushort* valueFixed, int length, ushort value)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this ushort[] array, ushort value)
        {
            if (array != null)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static ushort* IndexOf(ushort* valueFixed, int length, Func<ushort, bool> isValue)
        {
            for (ushort* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array != null)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public static ushort firstOrDefault(this ushort[] array, Func<ushort, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (ushort* valueFixed = array)
                {
                    ushort* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this ushort[] array, Func<ushort, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (ushort* valueFixed = array)
            {
                for (ushort* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static ushort[] replaceFirst(this ushort[] array, ushort value, Func<ushort, bool> isValue)
        {
            if (array == null) return NullValue<ushort>.Array;
            fixed (ushort* valueFixed = array)
            {
                ushort* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static ushort[] getArray<valueType>(this valueType[] array, Func<valueType, ushort> getValue)
        {
            if (array.isEmpty()) return NullValue<ushort>.Array;
            ushort[] newValues = new ushort[array.Length];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<ushort> GetFind(this ushort[] array, int index, int length, Func<ushort, bool> isValue)
        {
            ushort[] newValues = new ushort[length < sizeof(int) ? sizeof(int) : length];
            fixed (ushort* newValueFixed = newValues, valueFixed = array)
            {
                ushort* write = newValueFixed;
                for (ushort* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<ushort> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ushort> getFind(this ushort[] array, Func<ushort, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<ushort>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static ushort[] getFindArray(this ushort[] array, Func<ushort, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<ushort>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static ushort[] GetFindArray(ushort[] array, int index, int count, Func<ushort, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (ushort* valueFixed = array)
            {
                ushort* startFixed = valueFixed + index, end = startFixed + count;
                for (ushort* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    ushort[] newValues = new ushort[length];
                    fixed (ushort* newValueFixed = newValues)
                    {
                        ushort* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<ushort>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this ushort[] array, out ushort value)
        {
            if (array.isEmpty())
            {
                value = ushort.MinValue;
                return false;
            }
            fixed (ushort* valueFixed = array)
            {
                value = *valueFixed;
                for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort max(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, ushort> getKey, out ushort value)
        {
            if (array.isEmpty())
            {
                value = ushort.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                ushort nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort maxKey<valueType>(this valueType[] array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, ushort> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            ushort maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                ushort nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this ushort[] array, out ushort value)
        {
            if (array.isEmpty())
            {
                value = ushort.MaxValue;
                return false;
            }
            fixed (ushort* valueFixed = array)
            {
                value = *valueFixed;
                for (ushort* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort min(this ushort[] array, ushort nullValue)
        {
            ushort value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, ushort> getKey, out ushort value)
        {
            if (array.isEmpty())
            {
                value = ushort.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                ushort nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort minKey<valueType>(this valueType[] array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, ushort> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            ushort minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                ushort nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(short[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (short* valueFixed = array)
                {
                    for (short* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (short* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(short));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(short[] array, int index, int length)
        {
            fixed (short* valueFixed = array)
            {
                for (short* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    short value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] reverse(this short[] array)
        {
            if (array == null) return NullValue<short>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static short[] GetReverse(short[] array, int index, int length)
        {
            short[] newValues = new short[length];
            fixed (short* valueFixed = array, newValueFixed = newValues)
            {
                for (short* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] getReverse(this short[] array)
        {
            if (array == null || array.Length == 0) return NullValue<short>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static short* IndexOf(short* valueFixed, int length, short value)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this short[] array, short value)
        {
            if (array != null)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static short* IndexOf(short* valueFixed, int length, Func<short, bool> isValue)
        {
            for (short* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this short[] array, Func<short, bool> isValue)
        {
            if (array != null)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public static short firstOrDefault(this short[] array, Func<short, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (short* valueFixed = array)
                {
                    short* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this short[] array, Func<short, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (short* valueFixed = array)
            {
                for (short* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static short[] replaceFirst(this short[] array, short value, Func<short, bool> isValue)
        {
            if (array == null) return NullValue<short>.Array;
            fixed (short* valueFixed = array)
            {
                short* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static short[] getArray<valueType>(this valueType[] array, Func<valueType, short> getValue)
        {
            if (array.isEmpty()) return NullValue<short>.Array;
            short[] newValues = new short[array.Length];
            fixed (short* newValueFixed = newValues)
            {
                short* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<short> GetFind(this short[] array, int index, int length, Func<short, bool> isValue)
        {
            short[] newValues = new short[length < sizeof(int) ? sizeof(int) : length];
            fixed (short* newValueFixed = newValues, valueFixed = array)
            {
                short* write = newValueFixed;
                for (short* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<short> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<short> getFind(this short[] array, Func<short, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<short>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static short[] getFindArray(this short[] array, Func<short, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<short>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static short[] GetFindArray(short[] array, int index, int count, Func<short, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (short* valueFixed = array)
            {
                short* startFixed = valueFixed + index, end = startFixed + count;
                for (short* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    short[] newValues = new short[length];
                    fixed (short* newValueFixed = newValues)
                    {
                        short* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<short>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this short[] array, out short value)
        {
            if (array.isEmpty())
            {
                value = short.MinValue;
                return false;
            }
            fixed (short* valueFixed = array)
            {
                value = *valueFixed;
                for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short max(this short[] array, short nullValue)
        {
            short value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, short> getKey, out short value)
        {
            if (array.isEmpty())
            {
                value = short.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                short nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short maxKey<valueType>(this valueType[] array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, short> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            short maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                short nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this short[] array, out short value)
        {
            if (array.isEmpty())
            {
                value = short.MaxValue;
                return false;
            }
            fixed (short* valueFixed = array)
            {
                value = *valueFixed;
                for (short* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short min(this short[] array, short nullValue)
        {
            short value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, short> getKey, out short value)
        {
            if (array.isEmpty())
            {
                value = short.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                short nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short minKey<valueType>(this valueType[] array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, short> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            short minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                short nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(byte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (byte* valueFixed = array)
                {
                    for (byte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (byte* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(byte));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(byte[] array, int index, int length)
        {
            fixed (byte* valueFixed = array)
            {
                for (byte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    byte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] reverse(this byte[] array)
        {
            if (array == null) return NullValue<byte>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static byte[] GetReverse(byte[] array, int index, int length)
        {
            byte[] newValues = new byte[length];
            fixed (byte* valueFixed = array, newValueFixed = newValues)
            {
                for (byte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] getReverse(this byte[] array)
        {
            if (array == null || array.Length == 0) return NullValue<byte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static byte* IndexOf(byte* valueFixed, int length, byte value)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this byte[] array, byte value)
        {
            if (array != null)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static byte* IndexOf(byte* valueFixed, int length, Func<byte, bool> isValue)
        {
            for (byte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this byte[] array, Func<byte, bool> isValue)
        {
            if (array != null)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public static byte firstOrDefault(this byte[] array, Func<byte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (byte* valueFixed = array)
                {
                    byte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this byte[] array, Func<byte, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (byte* valueFixed = array)
            {
                for (byte* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static byte[] replaceFirst(this byte[] array, byte value, Func<byte, bool> isValue)
        {
            if (array == null) return NullValue<byte>.Array;
            fixed (byte* valueFixed = array)
            {
                byte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static byte[] getArray<valueType>(this valueType[] array, Func<valueType, byte> getValue)
        {
            if (array.isEmpty()) return NullValue<byte>.Array;
            byte[] newValues = new byte[array.Length];
            fixed (byte* newValueFixed = newValues)
            {
                byte* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<byte> GetFind(this byte[] array, int index, int length, Func<byte, bool> isValue)
        {
            byte[] newValues = new byte[length < sizeof(int) ? sizeof(int) : length];
            fixed (byte* newValueFixed = newValues, valueFixed = array)
            {
                byte* write = newValueFixed;
                for (byte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<byte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<byte> getFind(this byte[] array, Func<byte, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<byte>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static byte[] getFindArray(this byte[] array, Func<byte, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<byte>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static byte[] GetFindArray(byte[] array, int index, int count, Func<byte, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (byte* valueFixed = array)
            {
                byte* startFixed = valueFixed + index, end = startFixed + count;
                for (byte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    byte[] newValues = new byte[length];
                    fixed (byte* newValueFixed = newValues)
                    {
                        byte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<byte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this byte[] array, out byte value)
        {
            if (array.isEmpty())
            {
                value = byte.MinValue;
                return false;
            }
            fixed (byte* valueFixed = array)
            {
                value = *valueFixed;
                for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte max(this byte[] array, byte nullValue)
        {
            byte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, byte> getKey, out byte value)
        {
            if (array.isEmpty())
            {
                value = byte.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                byte nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte maxKey<valueType>(this valueType[] array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, byte> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            byte maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                byte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this byte[] array, out byte value)
        {
            if (array.isEmpty())
            {
                value = byte.MaxValue;
                return false;
            }
            fixed (byte* valueFixed = array)
            {
                value = *valueFixed;
                for (byte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte min(this byte[] array, byte nullValue)
        {
            byte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, byte> getKey, out byte value)
        {
            if (array.isEmpty())
            {
                value = byte.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                byte nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte minKey<valueType>(this valueType[] array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, byte> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            byte minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                byte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(sbyte[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (sbyte* valueFixed = array)
                {
                    for (sbyte* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (sbyte* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(sbyte));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(sbyte[] array, int index, int length)
        {
            fixed (sbyte* valueFixed = array)
            {
                for (sbyte* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    sbyte value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] reverse(this sbyte[] array)
        {
            if (array == null) return NullValue<sbyte>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static sbyte[] GetReverse(sbyte[] array, int index, int length)
        {
            sbyte[] newValues = new sbyte[length];
            fixed (sbyte* valueFixed = array, newValueFixed = newValues)
            {
                for (sbyte* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] getReverse(this sbyte[] array)
        {
            if (array == null || array.Length == 0) return NullValue<sbyte>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static sbyte* IndexOf(sbyte* valueFixed, int length, sbyte value)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this sbyte[] array, sbyte value)
        {
            if (array != null)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static sbyte* IndexOf(sbyte* valueFixed, int length, Func<sbyte, bool> isValue)
        {
            for (sbyte* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array != null)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public static sbyte firstOrDefault(this sbyte[] array, Func<sbyte, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (sbyte* valueFixed = array)
                {
                    sbyte* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (sbyte* valueFixed = array)
            {
                for (sbyte* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static sbyte[] replaceFirst(this sbyte[] array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array == null) return NullValue<sbyte>.Array;
            fixed (sbyte* valueFixed = array)
            {
                sbyte* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static sbyte[] getArray<valueType>(this valueType[] array, Func<valueType, sbyte> getValue)
        {
            if (array.isEmpty()) return NullValue<sbyte>.Array;
            sbyte[] newValues = new sbyte[array.Length];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<sbyte> GetFind(this sbyte[] array, int index, int length, Func<sbyte, bool> isValue)
        {
            sbyte[] newValues = new sbyte[length < sizeof(int) ? sizeof(int) : length];
            fixed (sbyte* newValueFixed = newValues, valueFixed = array)
            {
                sbyte* write = newValueFixed;
                for (sbyte* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<sbyte> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<sbyte> getFind(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<sbyte>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static sbyte[] getFindArray(this sbyte[] array, Func<sbyte, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<sbyte>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static sbyte[] GetFindArray(sbyte[] array, int index, int count, Func<sbyte, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (sbyte* valueFixed = array)
            {
                sbyte* startFixed = valueFixed + index, end = startFixed + count;
                for (sbyte* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    sbyte[] newValues = new sbyte[length];
                    fixed (sbyte* newValueFixed = newValues)
                    {
                        sbyte* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<sbyte>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this sbyte[] array, out sbyte value)
        {
            if (array.isEmpty())
            {
                value = sbyte.MinValue;
                return false;
            }
            fixed (sbyte* valueFixed = array)
            {
                value = *valueFixed;
                for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte max(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.isEmpty())
            {
                value = sbyte.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                sbyte nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte maxKey<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            sbyte maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                sbyte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this sbyte[] array, out sbyte value)
        {
            if (array.isEmpty())
            {
                value = sbyte.MaxValue;
                return false;
            }
            fixed (sbyte* valueFixed = array)
            {
                value = *valueFixed;
                for (sbyte* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte min(this sbyte[] array, sbyte nullValue)
        {
            sbyte value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (array.isEmpty())
            {
                value = sbyte.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                sbyte nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte minKey<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            sbyte minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                sbyte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(double[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (double* valueFixed = array)
                {
                    for (double* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (double* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(double));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(double[] array, int index, int length)
        {
            fixed (double* valueFixed = array)
            {
                for (double* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    double value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] reverse(this double[] array)
        {
            if (array == null) return NullValue<double>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static double[] GetReverse(double[] array, int index, int length)
        {
            double[] newValues = new double[length];
            fixed (double* valueFixed = array, newValueFixed = newValues)
            {
                for (double* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getReverse(this double[] array)
        {
            if (array == null || array.Length == 0) return NullValue<double>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static double* IndexOf(double* valueFixed, int length, double value)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this double[] array, double value)
        {
            if (array != null)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static double* IndexOf(double* valueFixed, int length, Func<double, bool> isValue)
        {
            for (double* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this double[] array, Func<double, bool> isValue)
        {
            if (array != null)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public static double firstOrDefault(this double[] array, Func<double, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (double* valueFixed = array)
                {
                    double* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this double[] array, Func<double, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (double* valueFixed = array)
            {
                for (double* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static double[] replaceFirst(this double[] array, double value, Func<double, bool> isValue)
        {
            if (array == null) return NullValue<double>.Array;
            fixed (double* valueFixed = array)
            {
                double* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static double[] getArray<valueType>(this valueType[] array, Func<valueType, double> getValue)
        {
            if (array.isEmpty()) return NullValue<double>.Array;
            double[] newValues = new double[array.Length];
            fixed (double* newValueFixed = newValues)
            {
                double* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<double> GetFind(this double[] array, int index, int length, Func<double, bool> isValue)
        {
            double[] newValues = new double[length < sizeof(int) ? sizeof(int) : length];
            fixed (double* newValueFixed = newValues, valueFixed = array)
            {
                double* write = newValueFixed;
                for (double* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<double> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> getFind(this double[] array, Func<double, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<double>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static double[] getFindArray(this double[] array, Func<double, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<double>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static double[] GetFindArray(double[] array, int index, int count, Func<double, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (double* valueFixed = array)
            {
                double* startFixed = valueFixed + index, end = startFixed + count;
                for (double* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    double[] newValues = new double[length];
                    fixed (double* newValueFixed = newValues)
                    {
                        double* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<double>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this double[] array, out double value)
        {
            if (array.isEmpty())
            {
                value = double.MinValue;
                return false;
            }
            fixed (double* valueFixed = array)
            {
                value = *valueFixed;
                for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double max(this double[] array, double nullValue)
        {
            double value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, double> getKey, out double value)
        {
            if (array.isEmpty())
            {
                value = double.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                double nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double maxKey<valueType>(this valueType[] array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, double> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            double maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                double nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this double[] array, out double value)
        {
            if (array.isEmpty())
            {
                value = double.MaxValue;
                return false;
            }
            fixed (double* valueFixed = array)
            {
                value = *valueFixed;
                for (double* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double min(this double[] array, double nullValue)
        {
            double value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, double> getKey, out double value)
        {
            if (array.isEmpty())
            {
                value = double.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                double nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double minKey<valueType>(this valueType[] array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, double> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            double minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                double nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(float[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (float* valueFixed = array)
                {
                    for (float* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (float* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(float));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(float[] array, int index, int length)
        {
            fixed (float* valueFixed = array)
            {
                for (float* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    float value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] reverse(this float[] array)
        {
            if (array == null) return NullValue<float>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static float[] GetReverse(float[] array, int index, int length)
        {
            float[] newValues = new float[length];
            fixed (float* valueFixed = array, newValueFixed = newValues)
            {
                for (float* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getReverse(this float[] array)
        {
            if (array == null || array.Length == 0) return NullValue<float>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static float* IndexOf(float* valueFixed, int length, float value)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this float[] array, float value)
        {
            if (array != null)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static float* IndexOf(float* valueFixed, int length, Func<float, bool> isValue)
        {
            for (float* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this float[] array, Func<float, bool> isValue)
        {
            if (array != null)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public static float firstOrDefault(this float[] array, Func<float, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (float* valueFixed = array)
                {
                    float* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this float[] array, Func<float, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (float* valueFixed = array)
            {
                for (float* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static float[] replaceFirst(this float[] array, float value, Func<float, bool> isValue)
        {
            if (array == null) return NullValue<float>.Array;
            fixed (float* valueFixed = array)
            {
                float* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static float[] getArray<valueType>(this valueType[] array, Func<valueType, float> getValue)
        {
            if (array.isEmpty()) return NullValue<float>.Array;
            float[] newValues = new float[array.Length];
            fixed (float* newValueFixed = newValues)
            {
                float* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<float> GetFind(this float[] array, int index, int length, Func<float, bool> isValue)
        {
            float[] newValues = new float[length < sizeof(int) ? sizeof(int) : length];
            fixed (float* newValueFixed = newValues, valueFixed = array)
            {
                float* write = newValueFixed;
                for (float* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<float> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> getFind(this float[] array, Func<float, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<float>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static float[] getFindArray(this float[] array, Func<float, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<float>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static float[] GetFindArray(float[] array, int index, int count, Func<float, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (float* valueFixed = array)
            {
                float* startFixed = valueFixed + index, end = startFixed + count;
                for (float* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    float[] newValues = new float[length];
                    fixed (float* newValueFixed = newValues)
                    {
                        float* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<float>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this float[] array, out float value)
        {
            if (array.isEmpty())
            {
                value = float.MinValue;
                return false;
            }
            fixed (float* valueFixed = array)
            {
                value = *valueFixed;
                for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float max(this float[] array, float nullValue)
        {
            float value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, float> getKey, out float value)
        {
            if (array.isEmpty())
            {
                value = float.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                float nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float maxKey<valueType>(this valueType[] array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, float> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            float maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                float nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this float[] array, out float value)
        {
            if (array.isEmpty())
            {
                value = float.MaxValue;
                return false;
            }
            fixed (float* valueFixed = array)
            {
                value = *valueFixed;
                for (float* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float min(this float[] array, float nullValue)
        {
            float value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, float> getKey, out float value)
        {
            if (array.isEmpty())
            {
                value = float.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                float nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float minKey<valueType>(this valueType[] array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, float> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            float minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                float nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(char[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (char* valueFixed = array)
                {
                    for (char* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (char* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(char));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(char[] array, int index, int length)
        {
            fixed (char* valueFixed = array)
            {
                for (char* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    char value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] reverse(this char[] array)
        {
            if (array == null) return NullValue<char>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static char[] GetReverse(char[] array, int index, int length)
        {
            char[] newValues = new char[length];
            fixed (char* valueFixed = array, newValueFixed = newValues)
            {
                for (char* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] getReverse(this char[] array)
        {
            if (array == null || array.Length == 0) return NullValue<char>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static char* IndexOf(char* valueFixed, int length, char value)
        {
            for (char* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this char[] array, char value)
        {
            if (array != null)
            {
                fixed (char* valueFixed = array)
                {
                    char* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static char* IndexOf(char* valueFixed, int length, Func<char, bool> isValue)
        {
            for (char* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this char[] array, Func<char, bool> isValue)
        {
            if (array != null)
            {
                fixed (char* valueFixed = array)
                {
                    char* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(char)</returns>
        public static char firstOrDefault(this char[] array, Func<char, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (char* valueFixed = array)
                {
                    char* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(char);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this char[] array, Func<char, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (char* valueFixed = array)
            {
                for (char* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static char[] replaceFirst(this char[] array, char value, Func<char, bool> isValue)
        {
            if (array == null) return NullValue<char>.Array;
            fixed (char* valueFixed = array)
            {
                char* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static char[] getArray<valueType>(this valueType[] array, Func<valueType, char> getValue)
        {
            if (array.isEmpty()) return NullValue<char>.Array;
            char[] newValues = new char[array.Length];
            fixed (char* newValueFixed = newValues)
            {
                char* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<char> GetFind(this char[] array, int index, int length, Func<char, bool> isValue)
        {
            char[] newValues = new char[length < sizeof(int) ? sizeof(int) : length];
            fixed (char* newValueFixed = newValues, valueFixed = array)
            {
                char* write = newValueFixed;
                for (char* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<char> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<char> getFind(this char[] array, Func<char, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<char>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static char[] getFindArray(this char[] array, Func<char, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<char>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static char[] GetFindArray(char[] array, int index, int count, Func<char, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (char* valueFixed = array)
            {
                char* startFixed = valueFixed + index, end = startFixed + count;
                for (char* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    char[] newValues = new char[length];
                    fixed (char* newValueFixed = newValues)
                    {
                        char* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<char>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this char[] array, out char value)
        {
            if (array.isEmpty())
            {
                value = char.MinValue;
                return false;
            }
            fixed (char* valueFixed = array)
            {
                value = *valueFixed;
                for (char* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char max(this char[] array, char nullValue)
        {
            char value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, char> getKey, out char value)
        {
            if (array.isEmpty())
            {
                value = char.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                char nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char maxKey<valueType>(this valueType[] array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, char> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            char maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                char nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this char[] array, out char value)
        {
            if (array.isEmpty())
            {
                value = char.MaxValue;
                return false;
            }
            fixed (char* valueFixed = array)
            {
                value = *valueFixed;
                for (char* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char min(this char[] array, char nullValue)
        {
            char value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, char> getKey, out char value)
        {
            if (array.isEmpty())
            {
                value = char.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                char nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char minKey<valueType>(this valueType[] array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, char> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            char minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                char nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public unsafe static partial class FixedArray
    {
        /// <summary>
        /// 移动数据块
        /// </summary>
        /// <param name="array">待处理数组</param>
        /// <param name="index">原始数据位置</param>
        /// <param name="writeIndex">目标数据位置</param>
        /// <param name="count">移动数据数量</param>
#if !MONO
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
#endif
        internal static void MoveNotNull(DateTime[] array, int index, int writeIndex, int count)
        {
#if MONO
            int endIndex = index + count;
            if (index < writeIndex && endIndex > writeIndex)
            {
                fixed (DateTime* valueFixed = array)
                {
                    for (DateTime* write = valueFixed + writeIndex + count, start = valueFixed + index, end = valueFixed + endIndex;
                        end != start;
                        *--write = *--end) ;
                }
            }
            else Array.Copy(array, index, array, writeIndex, count);
#else
            fixed (DateTime* valueFixed = array) AutoCSer.Win32.Kernel32.RtlMoveMemory(valueFixed + writeIndex, valueFixed + index, count * sizeof(DateTime));
#endif
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        internal static void Reverse(DateTime[] array, int index, int length)
        {
            fixed (DateTime* valueFixed = array)
            {
                for (DateTime* start = valueFixed + index, end = start + length; start < --end; ++start)
                {
                    DateTime value = *start;
                    *start = *end;
                    *end = value;
                }
            }
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] reverse(this DateTime[] array)
        {
            if (array == null) return NullValue<DateTime>.Array;
            if (array.Length > 1) Reverse(array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <returns>翻转后的新数组</returns>
        internal static DateTime[] GetReverse(DateTime[] array, int index, int length)
        {
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* valueFixed = array, newValueFixed = newValues)
            {
                for (DateTime* start = valueFixed + index, end = start + length, wirte = newValueFixed + length; start != end; *--wirte = *start++) ;
            }
            return newValues;
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getReverse(this DateTime[] array)
        {
            if (array == null || array.Length == 0) return NullValue<DateTime>.Array;
            return GetReverse(array, 0, array.Length);
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数据指针</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static DateTime* IndexOf(DateTime* valueFixed, int length, DateTime value)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (*start == value) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this DateTime[] array, DateTime value)
        {
            if (array != null)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, value);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="valueFixed">数组数据</param>
        /// <param name="length">匹配数据数量</param>
        /// <param name="isValue">匹配数据委托</param>
        /// <returns>匹配位置,失败为null</returns>
        internal static DateTime* IndexOf(DateTime* valueFixed, int length, Func<DateTime, bool> isValue)
        {
            for (DateTime* start = valueFixed, end = valueFixed + length; start != end; ++start)
            {
                if (isValue(*start)) return start;
            }
            return null;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array != null)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) return (int)(valueIndex - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public static DateTime firstOrDefault(this DateTime[] array, Func<DateTime, bool> isValue, int index)
        {
            if (array != null && (uint)index < (uint)array.Length)
            {
                fixed (DateTime* valueFixed = array)
                {
                    DateTime* valueIndex = IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            if (array == null) return 0;
            int value = 0;
            fixed (DateTime* valueFixed = array)
            {
                for (DateTime* end = valueFixed + array.Length; end != valueFixed; )
                {
                    if (isValue(*--end)) ++value;
                }
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static DateTime[] replaceFirst(this DateTime[] array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array == null) return NullValue<DateTime>.Array;
            fixed (DateTime* valueFixed = array)
            {
                DateTime* valueIndex = IndexOf(valueFixed, array.Length, isValue);
                if (valueIndex != null) *valueIndex = value;
            }
            return array;
        }
        /// <summary>
        /// 数据转换
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static DateTime[] getArray<valueType>(this valueType[] array, Func<valueType, DateTime> getValue)
        {
            if (array.isEmpty()) return NullValue<DateTime>.Array;
            DateTime[] newValues = new DateTime[array.Length];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* writeValue = newValueFixed;
                foreach (valueType value in array) *writeValue++ = getValue(value);
            }
            return newValues;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="length">翻转数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        internal static LeftArray<DateTime> GetFind(this DateTime[] array, int index, int length, Func<DateTime, bool> isValue)
        {
            DateTime[] newValues = new DateTime[length < sizeof(int) ? sizeof(int) : length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = array)
            {
                DateTime* write = newValueFixed;
                for (DateTime* start = valueFixed + index, end = valueFixed + length; start != end; ++start)
                {
                    if (isValue(*start)) *write++ = *start;
                }
                return new LeftArray<DateTime> { Array = newValues, Length = (int)(write - newValueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> getFind(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            return array.isEmpty() ? default(LeftArray<DateTime>) : GetFind(array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static DateTime[] getFindArray(this DateTime[] array, Func<DateTime, bool> isValue)
        {
            int length = array.length();
            if (length == 0) return NullValue<DateTime>.Array;
            {
                UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length = ((length + 63) >> 6) << 3);
                Pointer.Size data = pool.GetSize64(length);
                try
                {
                    Memory.ClearUnsafe(data.ULong, length >> 3);
                    return AutoCSer.Extension.FixedArray.GetFindArray(array, 0, array.Length, isValue, new AutoCSer.MemoryMap(data.Data));
                }
                finally { pool.PushOnly(ref data); }
            }
            
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="index">起始位置</param>
        /// <param name="count">匹配数据数量</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="map">匹配结果位图</param>
        /// <returns>匹配数组</returns>
        internal static DateTime[] GetFindArray(DateTime[] array, int index, int count, Func<DateTime, bool> isValue, MemoryMap map)
        {
            int length = 0, mapIndex = 0;
            fixed (DateTime* valueFixed = array)
            {
                DateTime* startFixed = valueFixed + index, end = startFixed + count;
                for (DateTime* start = startFixed; start != end; ++start, ++mapIndex)
                {
                    if (isValue(*start))
                    {
                        ++length;
                        map.Set(mapIndex);
                    }
                }
                if (length != 0)
                {
                    DateTime[] newValues = new DateTime[length];
                    fixed (DateTime* newValueFixed = newValues)
                    {
                        DateTime* write = newValueFixed + length;
                        while (mapIndex != 0)
                        {
                            if (map.Get(--mapIndex) != 0) *--write = startFixed[mapIndex];
                        }
                    }
                    return newValues;
                }
            }
            return NullValue<DateTime>.Array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max(this DateTime[] array, out DateTime value)
        {
            if (array.isEmpty())
            {
                value = DateTime.MinValue;
                return false;
            }
            fixed (DateTime* valueFixed = array)
            {
                value = *valueFixed;
                for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime max(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool maxKey<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.isEmpty())
            {
                value = DateTime.MinValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                DateTime nextKey = getKey(nextValue);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime maxKey<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return maxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool max<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            DateTime maxKey = getKey(value = array[0]);
            foreach (valueType nextValue in array)
            {
                DateTime nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType max<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min(this DateTime[] array, out DateTime value)
        {
            if (array.isEmpty())
            {
                value = DateTime.MaxValue;
                return false;
            }
            fixed (DateTime* valueFixed = array)
            {
                value = *valueFixed;
                for (DateTime* start = valueFixed + 1, end = valueFixed + array.Length; start != end; ++start)
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime min(this DateTime[] array, DateTime nullValue)
        {
            DateTime value;
            return min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool minKey<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (array.isEmpty())
            {
                value = DateTime.MaxValue;
                return false;
            }
            value = getKey(array[0]);
            foreach (valueType nextValue in array)
            {
                DateTime nextKey = getKey(nextValue);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime minKey<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return minKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool min<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (array.isEmpty())
            {
                value = default(valueType);
                return false;
            }
            value = array[0];
            DateTime minKey = getKey(value);
            foreach (valueType nextValue in array)
            {
                DateTime nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType min<valueType>(this valueType[] array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct ULongRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ulong* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ulong* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ulong* startIndex, ulong* endIndex)
            {
                do
                {
                    ulong leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ulong* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ulong value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> RangeSortDesc(ulong[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<ulong> UnsafeRangeSortDesc(ulong[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<ulong>);
            fixed (ulong* valueFixed = array)
            {
                ulong* start = valueFixed + skipCount;
                new ULongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<ulong> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetRangeSortDesc(ulong[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<ulong> UnsafeGetRangeSortDesc(ulong[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<ulong>);
            ulong[] newValues = new ulong[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(ulong));
            fixed (ulong* newValueFixed = newValues)
            {
                ulong* start = newValueFixed + skipCount;
                new ULongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<ulong> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> RangeSortDesc(ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<ulong> UnsafeRangeSortDesc(ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<ulong>);
            fixed (ulong* valueFixed = array)
            {
                ulong* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new ULongRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<ulong> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetRangeSortDesc(ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<ulong> UnsafeGetRangeSortDesc(ulong[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<ulong>);
            ulong[] newValues = new ulong[count];
            Buffer.BlockCopy(array, startIndex * sizeof(ulong), newValues, 0, count * sizeof(ulong));
            fixed (ulong* newValueFixed = newValues)
            {
                ulong* start = newValueFixed + skipCount;
                new ULongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<ulong> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct ULongRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public ULongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public ULongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(ULongSortIndex* startIndex, ULongSortIndex* endIndex)
            {
                do
                {
                    ULongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    ULongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    ULongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    ulong value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, ULongSortIndex* fixedIndex)
        {
            new ULongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            ULongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, ULongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (ULongSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new ULongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, ULongSortIndex* fixedIndex)
        {
            new ULongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            ULongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, ULongSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (ULongSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new ULongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct LongRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSort(long[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<long> UnsafeRangeSort(long[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + skipCount;
                new LongRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<long> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSort(long[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<long> UnsafeGetRangeSort(long[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            long[] newValues = new long[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(long));
            fixed (long* newValueFixed = newValues)
            {
                long* start = newValueFixed + skipCount;
                new LongRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<long> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSort(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<long> UnsafeRangeSort(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            fixed (long* valueFixed = array)
            {
                long* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new LongRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<long> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSort(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<long> UnsafeGetRangeSort(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            long[] newValues = new long[count];
            Buffer.BlockCopy(array, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
            fixed (long* newValueFixed = newValues)
            {
                long* start = newValueFixed + skipCount;
                new LongRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<long> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct LongRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public LongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public LongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(LongSortIndex* startIndex, LongSortIndex* endIndex)
            {
                do
                {
                    LongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    LongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    LongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            new LongRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            LongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, LongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (LongSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new LongRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            new LongRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            LongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, LongSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (LongSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new LongRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct LongRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public long* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public long* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(long* startIndex, long* endIndex)
            {
                do
                {
                    long leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    long* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    long value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSortDesc(long[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<long> UnsafeRangeSortDesc(long[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + skipCount;
                new LongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<long> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSortDesc(long[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<long> UnsafeGetRangeSortDesc(long[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            long[] newValues = new long[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(long));
            fixed (long* newValueFixed = newValues)
            {
                long* start = newValueFixed + skipCount;
                new LongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<long> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSortDesc(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<long> UnsafeRangeSortDesc(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            fixed (long* valueFixed = array)
            {
                long* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new LongRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<long> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSortDesc(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<long> UnsafeGetRangeSortDesc(long[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<long>);
            long[] newValues = new long[count];
            Buffer.BlockCopy(array, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
            fixed (long* newValueFixed = newValues)
            {
                long* start = newValueFixed + skipCount;
                new LongRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<long> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct LongRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public LongSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public LongSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(LongSortIndex* startIndex, LongSortIndex* endIndex)
            {
                do
                {
                    LongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    LongSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    LongSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    long value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            new LongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            LongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, LongSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (LongSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new LongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            new LongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            LongSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, LongSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (LongSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, LongSortIndex* fixedIndex)
        {
            LongSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new LongRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct UIntRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSort(uint[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<uint> UnsafeRangeSort(uint[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + skipCount;
                new UIntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<uint> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSort(uint[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<uint> UnsafeGetRangeSort(uint[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            uint[] newValues = new uint[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(uint));
            fixed (uint* newValueFixed = newValues)
            {
                uint* start = newValueFixed + skipCount;
                new UIntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<uint> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSort(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<uint> UnsafeRangeSort(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            fixed (uint* valueFixed = array)
            {
                uint* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new UIntRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<uint> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSort(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<uint> UnsafeGetRangeSort(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            uint[] newValues = new uint[count];
            Buffer.BlockCopy(array, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
            fixed (uint* newValueFixed = newValues)
            {
                uint* start = newValueFixed + skipCount;
                new UIntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<uint> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct UIntRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public UIntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public UIntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(UIntSortIndex* startIndex, UIntSortIndex* endIndex)
            {
                do
                {
                    UIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    UIntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    UIntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            new UIntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            UIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, UIntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (UIntSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new UIntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            new UIntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            UIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, UIntSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (UIntSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new UIntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct UIntRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public uint* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public uint* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(uint* startIndex, uint* endIndex)
            {
                do
                {
                    uint leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    uint* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    uint value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSortDesc(uint[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<uint> UnsafeRangeSortDesc(uint[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + skipCount;
                new UIntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<uint> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSortDesc(uint[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<uint> UnsafeGetRangeSortDesc(uint[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            uint[] newValues = new uint[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(uint));
            fixed (uint* newValueFixed = newValues)
            {
                uint* start = newValueFixed + skipCount;
                new UIntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<uint> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSortDesc(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<uint> UnsafeRangeSortDesc(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            fixed (uint* valueFixed = array)
            {
                uint* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new UIntRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<uint> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSortDesc(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<uint> UnsafeGetRangeSortDesc(uint[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<uint>);
            uint[] newValues = new uint[count];
            Buffer.BlockCopy(array, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
            fixed (uint* newValueFixed = newValues)
            {
                uint* start = newValueFixed + skipCount;
                new UIntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<uint> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct UIntRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public UIntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public UIntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(UIntSortIndex* startIndex, UIntSortIndex* endIndex)
            {
                do
                {
                    UIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    UIntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    UIntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    uint value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            new UIntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            UIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, UIntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (UIntSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new UIntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            new UIntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            UIntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, UIntSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (UIntSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new UIntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct IntRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSort(int[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<int> UnsafeRangeSort(int[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + skipCount;
                new IntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<int> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSort(int[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<int> UnsafeGetRangeSort(int[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            int[] newValues = new int[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(int));
            fixed (int* newValueFixed = newValues)
            {
                int* start = newValueFixed + skipCount;
                new IntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<int> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSort(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<int> UnsafeRangeSort(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            fixed (int* valueFixed = array)
            {
                int* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new IntRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<int> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSort(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<int> UnsafeGetRangeSort(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            int[] newValues = new int[count];
            Buffer.BlockCopy(array, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
            fixed (int* newValueFixed = newValues)
            {
                int* start = newValueFixed + skipCount;
                new IntRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<int> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct IntRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public IntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public IntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(IntSortIndex* startIndex, IntSortIndex* endIndex)
            {
                do
                {
                    IntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    IntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    IntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            new IntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            IntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, IntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (IntSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new IntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            new IntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            IntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, IntSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (IntSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new IntRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct IntRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public int* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public int* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(int* startIndex, int* endIndex)
            {
                do
                {
                    int leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    int* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    int value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSortDesc(int[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<int> UnsafeRangeSortDesc(int[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + skipCount;
                new IntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<int> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSortDesc(int[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<int> UnsafeGetRangeSortDesc(int[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            int[] newValues = new int[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(int));
            fixed (int* newValueFixed = newValues)
            {
                int* start = newValueFixed + skipCount;
                new IntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<int> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSortDesc(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<int> UnsafeRangeSortDesc(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            fixed (int* valueFixed = array)
            {
                int* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new IntRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<int> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSortDesc(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<int> UnsafeGetRangeSortDesc(int[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<int>);
            int[] newValues = new int[count];
            Buffer.BlockCopy(array, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
            fixed (int* newValueFixed = newValues)
            {
                int* start = newValueFixed + skipCount;
                new IntRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<int> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct IntRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public IntSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public IntSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(IntSortIndex* startIndex, IntSortIndex* endIndex)
            {
                do
                {
                    IntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    IntSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    IntSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    int value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            new IntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            IntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, IntSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (IntSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new IntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            new IntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            IntSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, IntSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (IntSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, IntSortIndex* fixedIndex)
        {
            IntSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new IntRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DoubleRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSort(double[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<double> UnsafeRangeSort(double[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            fixed (double* valueFixed = array)
            {
                double* start = valueFixed + skipCount;
                new DoubleRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<double> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSort(double[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<double> UnsafeGetRangeSort(double[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            double[] newValues = new double[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(double));
            fixed (double* newValueFixed = newValues)
            {
                double* start = newValueFixed + skipCount;
                new DoubleRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<double> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSort(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<double> UnsafeRangeSort(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            fixed (double* valueFixed = array)
            {
                double* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new DoubleRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<double> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSort(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<double> UnsafeGetRangeSort(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            double[] newValues = new double[count];
            Buffer.BlockCopy(array, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
            fixed (double* newValueFixed = newValues)
            {
                double* start = newValueFixed + skipCount;
                new DoubleRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<double> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DoubleRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DoubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DoubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DoubleSortIndex* startIndex, DoubleSortIndex* endIndex)
            {
                do
                {
                    DoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DoubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DoubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            new DoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            DoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, DoubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DoubleSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            new DoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            DoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, DoubleSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DoubleSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DoubleRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DoubleRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public double* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public double* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(double* startIndex, double* endIndex)
            {
                do
                {
                    double leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    double* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    double value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSortDesc(double[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<double> UnsafeRangeSortDesc(double[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            fixed (double* valueFixed = array)
            {
                double* start = valueFixed + skipCount;
                new DoubleRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<double> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSortDesc(double[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<double> UnsafeGetRangeSortDesc(double[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            double[] newValues = new double[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(double));
            fixed (double* newValueFixed = newValues)
            {
                double* start = newValueFixed + skipCount;
                new DoubleRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<double> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSortDesc(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<double> UnsafeRangeSortDesc(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            fixed (double* valueFixed = array)
            {
                double* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new DoubleRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<double> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSortDesc(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<double> UnsafeGetRangeSortDesc(double[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<double>);
            double[] newValues = new double[count];
            Buffer.BlockCopy(array, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
            fixed (double* newValueFixed = newValues)
            {
                double* start = newValueFixed + skipCount;
                new DoubleRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<double> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DoubleRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DoubleSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DoubleSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DoubleSortIndex* startIndex, DoubleSortIndex* endIndex)
            {
                do
                {
                    DoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DoubleSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DoubleSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    double value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            new DoubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            DoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, DoubleSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DoubleSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DoubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            new DoubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            DoubleSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, DoubleSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DoubleSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DoubleRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct FloatRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSort(float[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<float> UnsafeRangeSort(float[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            fixed (float* valueFixed = array)
            {
                float* start = valueFixed + skipCount;
                new FloatRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<float> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSort(float[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<float> UnsafeGetRangeSort(float[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            float[] newValues = new float[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(float));
            fixed (float* newValueFixed = newValues)
            {
                float* start = newValueFixed + skipCount;
                new FloatRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<float> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSort(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<float> UnsafeRangeSort(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            fixed (float* valueFixed = array)
            {
                float* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new FloatRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<float> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSort(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<float> UnsafeGetRangeSort(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            float[] newValues = new float[count];
            Buffer.BlockCopy(array, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
            fixed (float* newValueFixed = newValues)
            {
                float* start = newValueFixed + skipCount;
                new FloatRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<float> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct FloatRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public FloatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public FloatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(FloatSortIndex* startIndex, FloatSortIndex* endIndex)
            {
                do
                {
                    FloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    FloatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    FloatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            new FloatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            FloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, FloatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (FloatSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new FloatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            new FloatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            FloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, FloatSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (FloatSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new FloatRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct FloatRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public float* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public float* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(float* startIndex, float* endIndex)
            {
                do
                {
                    float leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    float* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    float value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSortDesc(float[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<float> UnsafeRangeSortDesc(float[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            fixed (float* valueFixed = array)
            {
                float* start = valueFixed + skipCount;
                new FloatRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<float> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSortDesc(float[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<float> UnsafeGetRangeSortDesc(float[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            float[] newValues = new float[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(float));
            fixed (float* newValueFixed = newValues)
            {
                float* start = newValueFixed + skipCount;
                new FloatRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<float> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSortDesc(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<float> UnsafeRangeSortDesc(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            fixed (float* valueFixed = array)
            {
                float* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new FloatRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<float> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSortDesc(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<float> UnsafeGetRangeSortDesc(float[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<float>);
            float[] newValues = new float[count];
            Buffer.BlockCopy(array, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
            fixed (float* newValueFixed = newValues)
            {
                float* start = newValueFixed + skipCount;
                new FloatRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<float> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct FloatRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public FloatSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public FloatSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(FloatSortIndex* startIndex, FloatSortIndex* endIndex)
            {
                do
                {
                    FloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    FloatSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    FloatSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    float value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            new FloatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            FloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, FloatSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (FloatSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new FloatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            new FloatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            FloatSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, FloatSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (FloatSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new FloatRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DateTimeRangeSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue > rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue > value)
                    {
                        if (leftValue > rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value > rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value > rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue > rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex < value) ++leftIndex;
                        while (value < *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSort(DateTime[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<DateTime> UnsafeRangeSort(DateTime[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + skipCount;
                new DateTimeRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<DateTime> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSort(DateTime[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<DateTime> UnsafeGetRangeSort(DateTime[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            DateTime[] newValues = new DateTime[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* start = newValueFixed + skipCount;
                new DateTimeRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<DateTime> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSort(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<DateTime> UnsafeRangeSort(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new DateTimeRangeSorter
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<DateTime> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSort(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<DateTime> UnsafeGetRangeSort(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            DateTime[] newValues = new DateTime[count];
            Buffer.BlockCopy(array, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* start = newValueFixed + skipCount;
                new DateTimeRangeSorter
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<DateTime> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DateTimeRangeIndexSorter
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTimeSortIndex* startIndex, DateTimeSortIndex* endIndex)
            {
                do
                {
                    DateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value > indexValue.Value)
                    {
                        if (leftValue.Value > rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value > rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value > rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value < value) ++leftIndex;
                        while (value < (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSort<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            new DateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            DateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSort<valueType>(valueType[] array, DateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DateTimeSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSort<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSort(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, getKey, skipCount, getCount, getValue, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            new DateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            DateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, DateTimeSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DateTimeSortIndex* fixedIndex = indexs) return getRangeSort(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSort(array, startIndex, count, getKey, skipCount, getCount, getValue, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSort<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DateTimeRangeIndexSorter
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickRangeSort
    {
        /// <summary>
        /// 范围排序器(一般用于获取分页)
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DateTimeRangeSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTime* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTime* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTime* startIndex, DateTime* endIndex)
            {
                do
                {
                    DateTime leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue < rightValue)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTime* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTime value = *averageIndex;
                    if (leftValue < value)
                    {
                        if (leftValue < rightValue)
                        {
                            *rightIndex = leftValue;
                            if (value < rightValue) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = value;
                                *averageIndex = value = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = leftValue;
                        }
                    }
                    else
                    {
                        if (value < rightValue)
                        {
                            *rightIndex = value;
                            if (leftValue < rightValue)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = value = leftValue;
                            }
                            else *averageIndex = value = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    do
                    {
                        while (*leftIndex > value) ++leftIndex;
                        while (value > *rightIndex) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSortDesc(DateTime[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            return UnsafeRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<DateTime> UnsafeRangeSortDesc(DateTime[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + skipCount;
                new DateTimeRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(valueFixed, valueFixed + array.Length - 1);
            }
            return new SubArray<DateTime> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSortDesc(DateTime[] array, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<DateTime> UnsafeGetRangeSortDesc(DateTime[] array, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            DateTime[] newValues = new DateTime[array.Length];
            Buffer.BlockCopy(array, 0, newValues, 0, array.Length * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* start = newValueFixed + skipCount;
                new DateTimeRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + skipCount - 1
                }.Sort(newValueFixed, newValueFixed + array.Length - 1);
            }
            return new SubArray<DateTime> { Array = newValues, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSortDesc(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (startIndex + count > array.Length) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] + count[" + AutoCSer.Extension.Number.toString(count) + "] > array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "]");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > count) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] + getCount[" + AutoCSer.Extension.Number.toString(getCount) + "] > count[" + AutoCSer.Extension.Number.toString(count) + "]");
            return UnsafeRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        internal static SubArray<DateTime> UnsafeRangeSortDesc(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* skip = valueFixed + (skipCount += startIndex), start = valueFixed + startIndex;
                new DateTimeRangeSorterDesc
                {
                    SkipCount = skip,
                    GetEndIndex = skip + getCount - 1
                }.Sort(start, start + --count);
            }
            return new SubArray<DateTime> { Array = array, Start = skipCount, Length = getCount };
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSortDesc(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的新数据</returns>
        internal static SubArray<DateTime> UnsafeGetRangeSortDesc(DateTime[] array, int startIndex, int count, int skipCount, int getCount)
        {
            if (getCount == 0) return default(SubArray<DateTime>);
            DateTime[] newValues = new DateTime[count];
            Buffer.BlockCopy(array, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* start = newValueFixed + skipCount;
                new DateTimeRangeSorterDesc
                {
                    SkipCount = start,
                    GetEndIndex = start + getCount - 1
                }.Sort(newValueFixed, newValueFixed + count - 1);
            }
            return new SubArray<DateTime> { Array = newValues, Start = skipCount, Length = getCount };
        }

        /// <summary>
        /// 索引范围排序器
        /// </summary>
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
        internal struct DateTimeRangeIndexSorterDesc
        {
            /// <summary>
            /// 跳过数据指针
            /// </summary>
            public DateTimeSortIndex* SkipCount;
            /// <summary>
            /// 最后一条记录指针-1
            /// </summary>
            public DateTimeSortIndex* GetEndIndex;
            /// <summary>
            /// 范围排序
            /// </summary>
            /// <param name="startIndex">起始指针</param>
            /// <param name="endIndex">结束指针-1</param>
            public void Sort(DateTimeSortIndex* startIndex, DateTimeSortIndex* endIndex)
            {
                do
                {
                    DateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                    int average = (int)(endIndex - startIndex) >> 1;
                    if (average == 0)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *startIndex = rightValue;
                            *endIndex = leftValue;
                        }
                        break;
                    }
                    DateTimeSortIndex* averageIndex = startIndex + average, leftIndex = startIndex, rightIndex = endIndex;
                    DateTimeSortIndex indexValue = *averageIndex;
                    if (leftValue.Value < indexValue.Value)
                    {
                        if (leftValue.Value < rightValue.Value)
                        {
                            *rightIndex = leftValue;
                            if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                            else
                            {
                                *leftIndex = indexValue;
                                *averageIndex = indexValue = rightValue;
                            }
                        }
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = leftValue;
                        }
                    }
                    else
                    {
                        if (indexValue.Value < rightValue.Value)
                        {
                            *rightIndex = indexValue;
                            if (leftValue.Value < rightValue.Value)
                            {
                                *leftIndex = rightValue;
                                *averageIndex = indexValue = leftValue;
                            }
                            else *averageIndex = indexValue = rightValue;
                        }
                    }
                    ++leftIndex;
                    --rightIndex;
                    DateTime value = indexValue.Value;
                    do
                    {
                        while ((*leftIndex).Value > value) ++leftIndex;
                        while (value > (*rightIndex).Value) --rightIndex;
                        if (leftIndex < rightIndex)
                        {
                            leftValue = *leftIndex;
                            *leftIndex = *rightIndex;
                            *rightIndex = leftValue;
                        }
                        else
                        {
                            if (leftIndex == rightIndex)
                            {
                                ++leftIndex;
                                --rightIndex;
                            }
                            break;
                        }
                    }
                    while (++leftIndex <= --rightIndex);
                    if (rightIndex - startIndex <= endIndex - leftIndex)
                    {
                        if (startIndex < rightIndex && rightIndex >= SkipCount) Sort(startIndex, rightIndex);
                        if (leftIndex > GetEndIndex) break;
                        startIndex = leftIndex;
                    }
                    else
                    {
                        if (leftIndex < endIndex && leftIndex <= GetEndIndex) Sort(leftIndex, endIndex);
                        if (rightIndex < SkipCount) break;
                        endIndex = rightIndex;
                    }
                }
                while (startIndex < endIndex);
            }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = array.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            new DateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            valueType[] newValues = new valueType[getCount];
            DateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, DateTimeSortIndex[] indexs, int skipCount, int getCount)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<valueType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DateTimeSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        internal static valueType[] UnsafeGetRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            if (getCount == 0) return NullValue<valueType>.Array;
            int size = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getRangeSortDesc<valueType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            valueType[] newValues = new valueType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = array[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            return UnsafeGetRangeSortDesc(array, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = array.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, getKey, skipCount, getCount, getValue, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = 0; index != array.Length; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            new DateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + array.Length - 1);
            returnType[] newValues = new returnType[getCount];
            DateTimeSortIndex* writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="indexs">排序索引</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, DateTimeSortIndex[] indexs, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (skipCount + getCount > array.Length) getCount = array.Length - skipCount;
            if (getCount == 0) return NullValue<returnType>.Array;
            if (array.Length != indexs.Length) throw new IndexOutOfRangeException("array.Length[" + AutoCSer.Extension.Number.toString(array.Length) + "] != indexs.Length[" + AutoCSer.Extension.Number.toString(indexs.Length) + "]");
            fixed (DateTimeSortIndex* fixedIndex = indexs) return getRangeSortDesc(array, skipCount, getCount, getValue, fixedIndex);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (startIndex < 0) throw new IndexOutOfRangeException("startIndex[" + AutoCSer.Extension.Number.toString(startIndex) + "] < 0");
            if (skipCount < 0) throw new IndexOutOfRangeException("skipCount[" + AutoCSer.Extension.Number.toString(skipCount) + "] < 0");
            if (getValue == null) throw new ArgumentNullException();
            if (startIndex + count > array.Length) count = array.Length - startIndex;
            if (skipCount + getCount > count) getCount = count - skipCount;
            return UnsafeGetRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序后的数组</returns>
        internal static returnType[] UnsafeGetRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            if (getCount == 0) return NullValue<returnType>.Array;
            int size = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getRangeSortDesc(array, startIndex, count, getKey, skipCount, getCount, getValue, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序范围数据数量</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="skipCount">跳过数据数量</param>
        /// <param name="getCount">排序数据数量</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static returnType[] getRangeSortDesc<valueType, returnType>(valueType[] array, int startIndex, int count, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex* writeIndex = fixedIndex;
            for (int index = startIndex, endIndex = startIndex + count; index != endIndex; (*writeIndex++).Set(getKey(array[index]), index++)) ;
            new DateTimeRangeIndexSorterDesc
            {
                SkipCount = fixedIndex + skipCount,
                GetEndIndex = fixedIndex + skipCount + getCount - 1
            }.Sort(fixedIndex, fixedIndex + count - 1);
            returnType[] newValues = new returnType[getCount];
            writeIndex = fixedIndex + skipCount;
            for (int index = 0; index != newValues.Length; ++index) newValues[index] = getValue(array[(*writeIndex++).Index]);
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(ulong* startIndex, ulong* endIndex)
        {
            do
            {
                ulong leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ulong* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ulong value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(ulong[] values)
        {
            if (values.Length > 1)
            {
                fixed (ulong* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static ulong[] GetSortDesc(ulong[] values)
        {
            if (values.Length == 0) return values;
            ulong[] newValue = new ulong[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(ulong));
            fixed (ulong* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(ulong[] values, int startIndex, int count)
        {
            fixed (ulong* valueFixed = values)
            {
                ulong* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static ulong[] GetSortDesc(ulong[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<ulong>.Array;
            ulong[] newValues = new ulong[count];
            Buffer.BlockCopy(values, startIndex * sizeof(ulong), newValues, 0, count * sizeof(ulong));
            fixed (ulong* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(ULongSortIndex* startIndex, ULongSortIndex* endIndex)
        {
            do
            {
                ULongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                ULongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                ULongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                ulong value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey)
        {
            int length = values.Length * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return ULongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int startIndex, int count)
        {
            int length = count * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int startIndex, int count, ULongSortIndex* fixedIndex)
        {
            ULongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return ULongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static long[] GetSort(long[] values)
        {
            if (values.Length == 0) return values;
            long[] newValue = new long[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
            fixed (long* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static long[] GetSort(long[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<long>.Array;
            long[] newValues = new long[count];
            Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(LongSortIndex* startIndex, LongSortIndex* endIndex)
        {
            do
            {
                LongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                LongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                LongSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, long> getKey)
        {
            int length = values.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, long> getKey, LongSortIndex* fixedIndex)
        {
            LongSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return LongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, long> getKey, int startIndex, int count)
        {
            int length = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, long> getKey, int startIndex, int count, LongSortIndex* fixedIndex)
        {
            LongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return LongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(long* startIndex, long* endIndex)
        {
            do
            {
                long leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                long* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                long value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(long[] values)
        {
            if (values.Length > 1)
            {
                fixed (long* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static long[] GetSortDesc(long[] values)
        {
            if (values.Length == 0) return values;
            long[] newValue = new long[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(long));
            fixed (long* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(long[] values, int startIndex, int count)
        {
            fixed (long* valueFixed = values)
            {
                long* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static long[] GetSortDesc(long[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<long>.Array;
            long[] newValues = new long[count];
            Buffer.BlockCopy(values, startIndex * sizeof(long), newValues, 0, count * sizeof(long));
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(LongSortIndex* startIndex, LongSortIndex* endIndex)
        {
            do
            {
                LongSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                LongSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                LongSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                long value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, long> getKey)
        {
            int length = values.Length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, long> getKey, LongSortIndex* fixedIndex)
        {
            LongSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return LongSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int startIndex, int count)
        {
            int length = count * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int startIndex, int count, LongSortIndex* fixedIndex)
        {
            LongSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return LongSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] GetSort(uint[] values)
        {
            if (values.Length == 0) return values;
            uint[] newValue = new uint[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
            fixed (uint* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] GetSort(uint[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<uint>.Array;
            uint[] newValues = new uint[count];
            Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(UIntSortIndex* startIndex, UIntSortIndex* endIndex)
        {
            do
            {
                UIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                UIntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                UIntSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, uint> getKey)
        {
            int length = values.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, uint> getKey, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return UIntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, uint> getKey, int startIndex, int count)
        {
            int length = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, uint> getKey, int startIndex, int count, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return UIntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(uint* startIndex, uint* endIndex)
        {
            do
            {
                uint leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                uint* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                uint value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(uint[] values)
        {
            if (values.Length > 1)
            {
                fixed (uint* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] GetSortDesc(uint[] values)
        {
            if (values.Length == 0) return values;
            uint[] newValue = new uint[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(uint));
            fixed (uint* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(uint[] values, int startIndex, int count)
        {
            fixed (uint* valueFixed = values)
            {
                uint* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static uint[] GetSortDesc(uint[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<uint>.Array;
            uint[] newValues = new uint[count];
            Buffer.BlockCopy(values, startIndex * sizeof(uint), newValues, 0, count * sizeof(uint));
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(UIntSortIndex* startIndex, UIntSortIndex* endIndex)
        {
            do
            {
                UIntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                UIntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                UIntSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                uint value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, uint> getKey)
        {
            int length = values.Length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return UIntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int startIndex, int count)
        {
            int length = count * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int startIndex, int count, UIntSortIndex* fixedIndex)
        {
            UIntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return UIntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static int[] GetSort(int[] values)
        {
            if (values.Length == 0) return values;
            int[] newValue = new int[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
            fixed (int* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static int[] GetSort(int[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<int>.Array;
            int[] newValues = new int[count];
            Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(IntSortIndex* startIndex, IntSortIndex* endIndex)
        {
            do
            {
                IntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                IntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                IntSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, int> getKey)
        {
            int length = values.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, int> getKey, IntSortIndex* fixedIndex)
        {
            IntSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return IntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, int> getKey, int startIndex, int count)
        {
            int length = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, int> getKey, int startIndex, int count, IntSortIndex* fixedIndex)
        {
            IntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return IntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(int* startIndex, int* endIndex)
        {
            do
            {
                int leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                int* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                int value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(int[] values)
        {
            if (values.Length > 1)
            {
                fixed (int* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static int[] GetSortDesc(int[] values)
        {
            if (values.Length == 0) return values;
            int[] newValue = new int[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(int));
            fixed (int* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(int[] values, int startIndex, int count)
        {
            fixed (int* valueFixed = values)
            {
                int* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static int[] GetSortDesc(int[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<int>.Array;
            int[] newValues = new int[count];
            Buffer.BlockCopy(values, startIndex * sizeof(int), newValues, 0, count * sizeof(int));
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(IntSortIndex* startIndex, IntSortIndex* endIndex)
        {
            do
            {
                IntSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                IntSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                IntSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                int value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, int> getKey)
        {
            int length = values.Length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, int> getKey, IntSortIndex* fixedIndex)
        {
            IntSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return IntSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int startIndex, int count)
        {
            int length = count * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int startIndex, int count, IntSortIndex* fixedIndex)
        {
            IntSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return IntSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] GetSort(double[] values)
        {
            if (values.Length == 0) return values;
            double[] newValue = new double[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
            fixed (double* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static double[] GetSort(double[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<double>.Array;
            double[] newValues = new double[count];
            Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(DoubleSortIndex* startIndex, DoubleSortIndex* endIndex)
        {
            do
            {
                DoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DoubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DoubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, double> getKey)
        {
            int length = values.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, double> getKey, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return DoubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, double> getKey, int startIndex, int count)
        {
            int length = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, double> getKey, int startIndex, int count, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return DoubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(double* startIndex, double* endIndex)
        {
            do
            {
                double leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                double* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                double value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(double[] values)
        {
            if (values.Length > 1)
            {
                fixed (double* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static double[] GetSortDesc(double[] values)
        {
            if (values.Length == 0) return values;
            double[] newValue = new double[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(double));
            fixed (double* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(double[] values, int startIndex, int count)
        {
            fixed (double* valueFixed = values)
            {
                double* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static double[] GetSortDesc(double[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<double>.Array;
            double[] newValues = new double[count];
            Buffer.BlockCopy(values, startIndex * sizeof(double), newValues, 0, count * sizeof(double));
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(DoubleSortIndex* startIndex, DoubleSortIndex* endIndex)
        {
            do
            {
                DoubleSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DoubleSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DoubleSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                double value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, double> getKey)
        {
            int length = values.Length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, double> getKey, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return DoubleSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int startIndex, int count)
        {
            int length = count * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int startIndex, int count, DoubleSortIndex* fixedIndex)
        {
            DoubleSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return DoubleSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] GetSort(float[] values)
        {
            if (values.Length == 0) return values;
            float[] newValue = new float[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
            fixed (float* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static float[] GetSort(float[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<float>.Array;
            float[] newValues = new float[count];
            Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(FloatSortIndex* startIndex, FloatSortIndex* endIndex)
        {
            do
            {
                FloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                FloatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                FloatSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, float> getKey)
        {
            int length = values.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, float> getKey, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return FloatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, float> getKey, int startIndex, int count)
        {
            int length = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, float> getKey, int startIndex, int count, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return FloatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(float* startIndex, float* endIndex)
        {
            do
            {
                float leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                float* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                float value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(float[] values)
        {
            if (values.Length > 1)
            {
                fixed (float* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static float[] GetSortDesc(float[] values)
        {
            if (values.Length == 0) return values;
            float[] newValue = new float[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(float));
            fixed (float* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(float[] values, int startIndex, int count)
        {
            fixed (float* valueFixed = values)
            {
                float* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static float[] GetSortDesc(float[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<float>.Array;
            float[] newValues = new float[count];
            Buffer.BlockCopy(values, startIndex * sizeof(float), newValues, 0, count * sizeof(float));
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(FloatSortIndex* startIndex, FloatSortIndex* endIndex)
        {
            do
            {
                FloatSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                FloatSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                FloatSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                float value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, float> getKey)
        {
            int length = values.Length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, float> getKey, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return FloatSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int startIndex, int count)
        {
            int length = count * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int startIndex, int count, FloatSortIndex* fixedIndex)
        {
            FloatSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return FloatSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sort(DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue > rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue > value)
                {
                    if (leftValue > rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value > rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value > rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue > rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex < value) ++leftIndex;
                    while (value < *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values) sort(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] GetSort(DateTime[] values)
        {
            if (values.Length == 0) return values;
            DateTime[] newValue = new DateTime[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValue, valueFixed = values) sort(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void Sort(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sort(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] GetSort(DateTime[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<DateTime>.Array;
            DateTime[] newValues = new DateTime[count];
            Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sort(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sort(DateTimeSortIndex* startIndex, DateTimeSortIndex* endIndex)
        {
            do
            {
                DateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value > indexValue.Value)
                {
                    if (leftValue.Value > rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value > rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value > rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value > rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value < value) ++leftIndex;
                    while (value < (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sort(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sort(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, DateTime> getKey)
        {
            int length = values.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, DateTime> getKey, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex.Create(fixedIndex, values, getKey);
            sort(fixedIndex, fixedIndex + values.Length - 1);
            return DateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSort<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count)
        {
            int length = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSort(values, getKey, startIndex, count, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSort<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sort(fixedIndex, fixedIndex + count - 1);
            return DateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickSort
    {
        /// <summary>
        /// 快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        private static void sortDesc(DateTime* startIndex, DateTime* endIndex)
        {
            do
            {
                DateTime leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue < rightValue)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTime* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTime value = *averageIndex;
                if (leftValue < value)
                {
                    if (leftValue < rightValue)
                    {
                        *rightIndex = leftValue;
                        if (value < rightValue) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = value;
                            *averageIndex = value = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = value;
                        *averageIndex = value = leftValue;
                    }
                }
                else
                {
                    if (value < rightValue)
                    {
                        *rightIndex = value;
                        if (leftValue < rightValue)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = value = leftValue;
                        }
                        else *averageIndex = value = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                do
                {
                    while (*leftIndex > value) ++leftIndex;
                    while (value > *rightIndex) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(DateTime[] values)
        {
            if (values.Length > 1)
            {
                fixed (DateTime* valueFixed = values) sortDesc(valueFixed, valueFixed + values.Length - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] GetSortDesc(DateTime[] values)
        {
            if (values.Length == 0) return values;
            DateTime[] newValue = new DateTime[values.Length];
            Buffer.BlockCopy(values, 0, newValue, 0, values.Length * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValue, valueFixed = values) sortDesc(newValueFixed, newValueFixed + values.Length - 1);
            return newValue;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static void SortDesc(DateTime[] values, int startIndex, int count)
        {
            fixed (DateTime* valueFixed = values)
            {
                DateTime* start = valueFixed + startIndex;
                sortDesc(start, start + count - 1);
            }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的新数组</returns>
        public static DateTime[] GetSortDesc(DateTime[] values, int startIndex, int count)
        {
            if (count == 0) return NullValue<DateTime>.Array;
            DateTime[] newValues = new DateTime[count];
            Buffer.BlockCopy(values, startIndex * sizeof(DateTime), newValues, 0, count * sizeof(DateTime));
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                if (--count > 0) sortDesc(newValueFixed, newValueFixed + count);
            }
            return newValues;
        }
        /// <summary>
        /// 索引快速排序子过程
        /// </summary>
        /// <param name="startIndex">起始位置</param>
        /// <param name="endIndex">结束位置-1</param>
        internal static void sortDesc(DateTimeSortIndex* startIndex, DateTimeSortIndex* endIndex)
        {
            do
            {
                DateTimeSortIndex leftValue = *startIndex, rightValue = *endIndex;
                int average = (int)(endIndex - startIndex) >> 1;
                if (average == 0)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *startIndex = rightValue;
                        *endIndex = leftValue;
                    }
                    break;
                }
                DateTimeSortIndex* leftIndex = startIndex, rightIndex = endIndex, averageIndex = startIndex + average;
                DateTimeSortIndex indexValue = *averageIndex;
                if (leftValue.Value < indexValue.Value)
                {
                    if (leftValue.Value < rightValue.Value)
                    {
                        *rightIndex = leftValue;
                        if (indexValue.Value < rightValue.Value) *leftIndex = rightValue;
                        else
                        {
                            *leftIndex = indexValue;
                            *averageIndex = indexValue = rightValue;
                        }
                    }
                    else
                    {
                        *leftIndex = indexValue;
                        *averageIndex = indexValue = leftValue;
                    }
                }
                else
                {
                    if (indexValue.Value < rightValue.Value)
                    {
                        *rightIndex = indexValue;
                        if (leftValue.Value < rightValue.Value)
                        {
                            *leftIndex = rightValue;
                            *averageIndex = indexValue = leftValue;
                        }
                        else *averageIndex = indexValue = rightValue;
                    }
                }
                ++leftIndex;
                --rightIndex;
                DateTime value = indexValue.Value;
                do
                {
                    while ((*leftIndex).Value > value) ++leftIndex;
                    while (value > (*rightIndex).Value) --rightIndex;
                    if (leftIndex < rightIndex)
                    {
                        leftValue = *leftIndex;
                        *leftIndex = *rightIndex;
                        *rightIndex = leftValue;
                    }
                    else
                    {
                        if (leftIndex == rightIndex)
                        {
                            ++leftIndex;
                            --rightIndex;
                        }
                        break;
                    }
                }
                while (++leftIndex <= --rightIndex);
                if (rightIndex - startIndex <= endIndex - leftIndex)
                {
                    if (startIndex < rightIndex) sortDesc(startIndex, rightIndex);
                    startIndex = leftIndex;
                }
                else
                {
                    if (leftIndex < endIndex) sortDesc(leftIndex, endIndex);
                    endIndex = rightIndex;
                }
            }
            while (startIndex < endIndex);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey)
        {
            int length = values.Length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex.Create(fixedIndex, values, getKey);
            sortDesc(fixedIndex, fixedIndex + values.Length - 1);
            return DateTimeSortIndex.Create(fixedIndex, values, values.Length);
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        public static valueType[] GetSortDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count)
        {
            int length = count * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize(length);
            try
            {
                return getSortDesc(values, getKey, startIndex, count, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="fixedIndex">索引位置</param>
        /// <returns>排序后的数组</returns>
        private static valueType[] getSortDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int startIndex, int count, DateTimeSortIndex* fixedIndex)
        {
            DateTimeSortIndex.Create(fixedIndex, values, getKey, startIndex, count);
            sortDesc(fixedIndex, fixedIndex + count - 1);
            return DateTimeSortIndex.Create(fixedIndex, values, count);
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<ulong> GetTopDesc(ulong[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<ulong>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                ulong[] newValues = new ulong[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<ulong> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ulong> TopDesc(ulong[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<ulong>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<ulong> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<ulong> getTopDesc(ulong[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] newValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, valueFixed = values)
            {
                ulong* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(ulong));
                ulong* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.ULongRangeSorterDesc sort = new FixedArrayQuickRangeSort.ULongRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (ulong maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<ulong> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static ulong[] getRemoveTopDesc(ulong[] values, int count)
        {
            ulong[] newValues = new ulong[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            ulong[] removeValues = new ulong[length];
            fixed (ulong* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(ulong);
                ulong* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(ulong));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(ulong));
                ulong* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.ULongRangeSorterDesc sort = new FixedArrayQuickRangeSort.ULongRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (ulong maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(ulong));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count, int length, ULongSortIndex* indexFixed)
        {
            ULongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            ULongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.ULongRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.ULongRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (ulong maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(ULongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (ULongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, ulong> getKey, int count, valueType[] newValues, int length, ULongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            ULongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            ULongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.ULongRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.ULongRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (ulong maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                ulong value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<long> GetTop(long[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<long>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                long[] newValues = new long[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<long> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> Top(long[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<long>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<long> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<long> getTop(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.LongRangeSorter sort = new FixedArrayQuickRangeSort.LongRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<long> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static long[] getRemoveTop(long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.LongRangeSorter sort = new FixedArrayQuickRangeSort.LongRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, long> getKey, int count, int length, LongSortIndex* indexFixed)
        {
            LongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            LongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.LongRangeIndexSorter sort = new FixedArrayQuickRangeSort.LongRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, long> getKey, int count, valueType[] newValues, int length, LongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            LongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            LongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.LongRangeIndexSorter sort = new FixedArrayQuickRangeSort.LongRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<long> GetTopDesc(long[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<long>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                long[] newValues = new long[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<long> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> TopDesc(long[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<long>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<long> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<long> getTopDesc(long[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] newValues = new long[length];
            fixed (long* newValueFixed = newValues, valueFixed = values)
            {
                long* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(long));
                long* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.LongRangeSorterDesc sort = new FixedArrayQuickRangeSort.LongRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (long maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<long> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static long[] getRemoveTopDesc(long[] values, int count)
        {
            long[] newValues = new long[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            long[] removeValues = new long[length];
            fixed (long* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(long);
                long* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(long));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(long));
                long* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.LongRangeSorterDesc sort = new FixedArrayQuickRangeSort.LongRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (long maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(long));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count, int length, LongSortIndex* indexFixed)
        {
            LongSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            LongSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.LongRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.LongRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (long maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(LongSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (LongSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, long> getKey, int count, valueType[] newValues, int length, LongSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            LongSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            LongSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.LongRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.LongRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (long maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                long value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<uint> GetTop(uint[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<uint>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                uint[] newValues = new uint[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<uint> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> Top(uint[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<uint>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<uint> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<uint> getTop(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.UIntRangeSorter sort = new FixedArrayQuickRangeSort.UIntRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<uint> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static uint[] getRemoveTop(uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.UIntRangeSorter sort = new FixedArrayQuickRangeSort.UIntRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, uint> getKey, int count, int length, UIntSortIndex* indexFixed)
        {
            UIntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            UIntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.UIntRangeIndexSorter sort = new FixedArrayQuickRangeSort.UIntRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, uint> getKey, int count, valueType[] newValues, int length, UIntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            UIntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            UIntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.UIntRangeIndexSorter sort = new FixedArrayQuickRangeSort.UIntRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<uint> GetTopDesc(uint[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<uint>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                uint[] newValues = new uint[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<uint> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> TopDesc(uint[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<uint>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<uint> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<uint> getTopDesc(uint[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] newValues = new uint[length];
            fixed (uint* newValueFixed = newValues, valueFixed = values)
            {
                uint* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(uint));
                uint* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.UIntRangeSorterDesc sort = new FixedArrayQuickRangeSort.UIntRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (uint maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<uint> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static uint[] getRemoveTopDesc(uint[] values, int count)
        {
            uint[] newValues = new uint[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            uint[] removeValues = new uint[length];
            fixed (uint* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(uint);
                uint* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(uint));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(uint));
                uint* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.UIntRangeSorterDesc sort = new FixedArrayQuickRangeSort.UIntRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (uint maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(uint));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count, int length, UIntSortIndex* indexFixed)
        {
            UIntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            UIntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.UIntRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.UIntRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (uint maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(UIntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (UIntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, uint> getKey, int count, valueType[] newValues, int length, UIntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            UIntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            UIntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.UIntRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.UIntRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (uint maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                uint value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<int> GetTop(int[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<int>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                int[] newValues = new int[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<int> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> Top(int[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<int>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<int> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<int> getTop(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.IntRangeSorter sort = new FixedArrayQuickRangeSort.IntRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<int> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static int[] getRemoveTop(int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.IntRangeSorter sort = new FixedArrayQuickRangeSort.IntRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, int> getKey, int count, int length, IntSortIndex* indexFixed)
        {
            IntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            IntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.IntRangeIndexSorter sort = new FixedArrayQuickRangeSort.IntRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, int> getKey, int count, valueType[] newValues, int length, IntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            IntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            IntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.IntRangeIndexSorter sort = new FixedArrayQuickRangeSort.IntRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<int> GetTopDesc(int[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<int>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                int[] newValues = new int[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<int> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> TopDesc(int[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<int>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<int> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<int> getTopDesc(int[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] newValues = new int[length];
            fixed (int* newValueFixed = newValues, valueFixed = values)
            {
                int* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(int));
                int* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.IntRangeSorterDesc sort = new FixedArrayQuickRangeSort.IntRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (int maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<int> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static int[] getRemoveTopDesc(int[] values, int count)
        {
            int[] newValues = new int[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            int[] removeValues = new int[length];
            fixed (int* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(int);
                int* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(int));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(int));
                int* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.IntRangeSorterDesc sort = new FixedArrayQuickRangeSort.IntRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (int maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(int));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count, int length, IntSortIndex* indexFixed)
        {
            IntSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            IntSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.IntRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.IntRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (int maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(IntSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (IntSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, int> getKey, int count, valueType[] newValues, int length, IntSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            IntSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            IntSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.IntRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.IntRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (int maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                int value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<double> GetTop(double[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<double>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                double[] newValues = new double[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<double> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> Top(double[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<double>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<double> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<double> getTop(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.DoubleRangeSorter sort = new FixedArrayQuickRangeSort.DoubleRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<double> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static double[] getRemoveTop(double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.DoubleRangeSorter sort = new FixedArrayQuickRangeSort.DoubleRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, double> getKey, int count, int length, DoubleSortIndex* indexFixed)
        {
            DoubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            DoubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.DoubleRangeIndexSorter sort = new FixedArrayQuickRangeSort.DoubleRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, double> getKey, int count, valueType[] newValues, int length, DoubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            DoubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            DoubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.DoubleRangeIndexSorter sort = new FixedArrayQuickRangeSort.DoubleRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<double> GetTopDesc(double[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<double>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                double[] newValues = new double[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<double> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> TopDesc(double[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<double>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<double> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<double> getTopDesc(double[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] newValues = new double[length];
            fixed (double* newValueFixed = newValues, valueFixed = values)
            {
                double* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(double));
                double* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.DoubleRangeSorterDesc sort = new FixedArrayQuickRangeSort.DoubleRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (double maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<double> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static double[] getRemoveTopDesc(double[] values, int count)
        {
            double[] newValues = new double[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            double[] removeValues = new double[length];
            fixed (double* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(double);
                double* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(double));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(double));
                double* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.DoubleRangeSorterDesc sort = new FixedArrayQuickRangeSort.DoubleRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (double maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(double));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count, int length, DoubleSortIndex* indexFixed)
        {
            DoubleSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            DoubleSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.DoubleRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.DoubleRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (double maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DoubleSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (DoubleSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, double> getKey, int count, valueType[] newValues, int length, DoubleSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            DoubleSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            DoubleSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.DoubleRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.DoubleRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (double maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                double value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<float> GetTop(float[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<float>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                float[] newValues = new float[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<float> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> Top(float[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<float>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<float> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<float> getTop(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.FloatRangeSorter sort = new FixedArrayQuickRangeSort.FloatRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<float> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static float[] getRemoveTop(float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.FloatRangeSorter sort = new FixedArrayQuickRangeSort.FloatRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, float> getKey, int count, int length, FloatSortIndex* indexFixed)
        {
            FloatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            FloatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.FloatRangeIndexSorter sort = new FixedArrayQuickRangeSort.FloatRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, float> getKey, int count, valueType[] newValues, int length, FloatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            FloatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            FloatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.FloatRangeIndexSorter sort = new FixedArrayQuickRangeSort.FloatRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<float> GetTopDesc(float[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<float>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                float[] newValues = new float[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<float> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> TopDesc(float[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<float>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<float> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<float> getTopDesc(float[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] newValues = new float[length];
            fixed (float* newValueFixed = newValues, valueFixed = values)
            {
                float* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(float));
                float* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.FloatRangeSorterDesc sort = new FixedArrayQuickRangeSort.FloatRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (float maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<float> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static float[] getRemoveTopDesc(float[] values, int count)
        {
            float[] newValues = new float[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            float[] removeValues = new float[length];
            fixed (float* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(float);
                float* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(float));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(float));
                float* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.FloatRangeSorterDesc sort = new FixedArrayQuickRangeSort.FloatRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (float maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(float));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count, int length, FloatSortIndex* indexFixed)
        {
            FloatSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            FloatSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.FloatRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.FloatRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (float maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(FloatSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (FloatSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, float> getKey, int count, valueType[] newValues, int length, FloatSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            FloatSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            FloatSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.FloatRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.FloatRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (float maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                float value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<DateTime> GetTop(DateTime[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<DateTime>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            else
            {
                DateTime[] newValues = new DateTime[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<DateTime> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> Top(DateTime[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<DateTime>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTop(values, count);
                values = getRemoveTop(values, count);
            }
            return new LeftArray<DateTime> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<DateTime> getTop(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.DateTimeRangeSorter sort = new FixedArrayQuickRangeSort.DateTimeRangeSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex < maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<DateTime> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static DateTime[] getRemoveTop(DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.DateTimeRangeSorter sort = new FixedArrayQuickRangeSort.DateTimeRangeSorter { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex <= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTop<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] Top<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTop(values, getKey, count);
            return getRemoveTop(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTop(values, getKey, count, length, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTop<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count, int length, DateTimeSortIndex* indexFixed)
        {
            DateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            DateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.DateTimeRangeIndexSorter sort = new FixedArrayQuickRangeSort.DateTimeRangeIndexSorter { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value < maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTop<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTop(values, getKey, count, newValues, length, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTop<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count, valueType[] newValues, int length, DateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            DateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            DateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.DateTimeRangeIndexSorter sort = new FixedArrayQuickRangeSort.DateTimeRangeIndexSorter { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value <= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 快速排序
    /// </summary>
    internal static unsafe partial class FixedArrayQuickTopSort
    {
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        public static LeftArray<DateTime> GetTopDesc(DateTime[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<DateTime>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            else
            {
                DateTime[] newValues = new DateTime[values.Length];
                Array.Copy(values, 0, newValues, 0, values.Length);
                values = newValues;
            }
            return new LeftArray<DateTime> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> TopDesc(DateTime[] values, int count)
        {
            if (values == null || count <= 0) return default(LeftArray<DateTime>);
            if (count < values.Length)
            {
                if (count <= values.Length >> 1) return getTopDesc(values, count);
                values = getRemoveTopDesc(values, count);
            }
            return new LeftArray<DateTime> { Array = values, Length = values.Length };
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static LeftArray<DateTime> getTopDesc(DateTime[] values, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] newValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, valueFixed = values)
            {
                DateTime* readIndex = valueFixed + values.Length - length;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), newValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, newValueFixed, length * sizeof(DateTime));
                DateTime* writeStat = newValueFixed + count, writeEnd = newValueFixed + --length, writeIndex = writeStat;
                FixedArrayQuickRangeSort.DateTimeRangeSorterDesc sort = new FixedArrayQuickRangeSort.DateTimeRangeSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
                sort.Sort(newValueFixed, writeEnd);
                for (DateTime maxValue = *sort.SkipCount; readIndex != valueFixed; )
                {
                    if (*--readIndex > maxValue)
                    {
                        *writeIndex = *readIndex;
                        if (writeIndex == writeEnd)
                        {
                            sort.Sort(newValueFixed, writeEnd);
                            writeIndex = writeStat;
                            maxValue = *sort.SkipCount;
                        }
                        else ++writeIndex;
                    }
                }
                if (writeIndex != writeStat) sort.Sort(newValueFixed, --writeIndex);
            }
            return new LeftArray<DateTime> { Array = newValues, Length = count };
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <param name="values">待排序数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static DateTime[] getRemoveTopDesc(DateTime[] values, int count)
        {
            DateTime[] newValues = new DateTime[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length);
            DateTime[] removeValues = new DateTime[length];
            fixed (DateTime* newValueFixed = newValues, removeFixed = removeValues, valueFixed = values)
            {
                int copyCount = length - count, copyLength = copyCount * sizeof(DateTime);
                DateTime* readIndex = valueFixed + values.Length - length, removeStart = removeFixed + copyCount;
                Buffer.BlockCopy(values, (int)((byte*)readIndex - (byte*)valueFixed), removeValues, 0, length * sizeof(DateTime));
                //unsafer.memory.Copy(readIndex, removeFixed, length * sizeof(DateTime));
                DateTime* removeEnd = removeFixed + --length, removeIndex = removeStart, writeIndex = newValueFixed + copyCount;
                FixedArrayQuickRangeSort.DateTimeRangeSorterDesc sort = new FixedArrayQuickRangeSort.DateTimeRangeSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
                sort.Sort(removeFixed, removeEnd);
                Buffer.BlockCopy(removeValues, 0, newValues, 0, copyLength);
                //unsafer.memory.Copy(removeFixed, newValueFixed, copyLength);
                for (DateTime maxValue = *removeStart; readIndex != valueFixed; )
                {
                    if (*--readIndex >= maxValue) *writeIndex++ = *readIndex;
                    else
                    {
                        *--removeIndex = *readIndex;
                        if (removeIndex == removeFixed)
                        {
                            sort.Sort(removeFixed, removeEnd);
                            removeIndex = removeStart;
                            maxValue = *removeStart;
                            Buffer.BlockCopy(removeValues, 0, newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), copyLength);
                            //unsafer.memory.Copy(removeFixed, writeIndex, copyLength);
                            writeIndex += copyCount;
                        }
                    }
                }
                if (removeIndex != removeStart)
                {
                    sort.Sort(removeIndex, removeEnd);
                    Buffer.BlockCopy(removeValues, (int)((byte*)removeIndex - (byte*)removeFixed), newValues, (int)((byte*)writeIndex - (byte*)newValueFixed), (int)((byte*)removeStart - (byte*)removeIndex));
                    //unsafer.memory.Copy(removeIndex, writeIndex, (int)(removeStart - removeIndex) * sizeof(DateTime));
                }
            }
            return newValues;
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetTopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return AutoCSer.Extension.ArrayExtension.copy(values);
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] TopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            if (values == null || count <= 0) return NullValue<valueType>.Array;
            if (count >= values.Length) return values;
            if (count <= values.Length >> 1) return getTopDesc(values, getKey, count);
            return getRemoveTopDesc(values, getKey, count);
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                return getTopDesc(values, getKey, count, length, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 排序取Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="indexFixed">索引位置</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getTopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count, int length, DateTimeSortIndex* indexFixed)
        {
            DateTimeSortIndex* writeEnd = indexFixed;
            int index = 0;
            while (index != length) (*writeEnd++).Set(getKey(values[index]), index++);
            DateTimeSortIndex* writeStat = indexFixed + count, writeIndex = writeStat;
            FixedArrayQuickRangeSort.DateTimeRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.DateTimeRangeIndexSorterDesc { SkipCount = writeStat - 1, GetEndIndex = writeStat - 1 };
            sort.Sort(indexFixed, --writeEnd);
            for (DateTime maxValue = (*sort.SkipCount).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value > maxValue)
                {
                    (*writeIndex).Set(value, index);
                    if (writeIndex == writeEnd)
                    {
                        sort.Sort(indexFixed, writeEnd);
                        writeIndex = writeStat;
                        maxValue = (*sort.SkipCount).Value;
                    }
                    else ++writeIndex;
                }
            }
            if (writeIndex != writeStat) sort.Sort(indexFixed, --writeIndex);
            valueType[] newValues = new valueType[count];
            for (writeIndex = indexFixed, index = 0; index != count; ++index) newValues[index] = values[(*writeIndex++).Index];
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数据</returns>
        private static valueType[] getRemoveTopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count)
        {
            valueType[] newValues = new valueType[count];
            count = values.Length - count;
            uint sqrtMod;
            int length = Math.Min(Math.Max(count << 2, count + (int)AutoCSer.Extension.Number.sqrt((uint)values.Length, out sqrtMod)), values.Length), size = length * sizeof(DateTimeSortIndex);
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(size);
            Pointer.Size data = pool.GetSize(size);
            try
            {
                removeTopDesc(values, getKey, count, newValues, length, (DateTimeSortIndex*)data.Data);
            }
            finally { pool.PushOnly(ref data); }
            return newValues;
        }
        /// <summary>
        /// 排序去除Top N
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="values">待排序数组</param>
        /// <param name="getKey">排序键值获取器</param>
        /// <param name="count">排序数据数量</param>
        /// <param name="newValues">目标数据数组</param>
        /// <param name="length">排序缓存区尺寸</param>
        /// <param name="removeFixed">索引位置</param>
        private static void removeTopDesc<valueType>(valueType[] values, Func<valueType, DateTime> getKey, int count, valueType[] newValues, int length, DateTimeSortIndex* removeFixed)
        {
            int index = 0, writeIndex = 0;
            DateTimeSortIndex* removeEnd = removeFixed;
            while (index != length) (*removeEnd++).Set(getKey(values[index]), index++);
            DateTimeSortIndex* removeStart = removeFixed + (count = length - count), removeIndex = removeFixed;
            FixedArrayQuickRangeSort.DateTimeRangeIndexSorterDesc sort = new FixedArrayQuickRangeSort.DateTimeRangeIndexSorterDesc { SkipCount = removeStart, GetEndIndex = removeStart };
            sort.Sort(removeFixed, --removeEnd);
            while (writeIndex != count) newValues[writeIndex++] = values[(*removeIndex++).Index];
            for (DateTime maxValue = (*removeStart).Value; index != values.Length; ++index)
            {
                DateTime value = getKey(values[index]);
                if (value >= maxValue) newValues[writeIndex++] = values[index];
                else
                {
                    (*--removeIndex).Set(value, index);
                    if (removeIndex == removeFixed)
                    {
                        sort.Sort(removeFixed, removeEnd);
                        for (removeIndex = removeFixed; removeIndex != removeStart; newValues[writeIndex++] = values[(*removeIndex++).Index]) ;
                        maxValue = (*removeStart).Value;
                    }
                }
            }
            if (removeIndex != removeStart)
            {
                sort.Sort(removeIndex, removeEnd);
                while (removeIndex != removeStart) newValues[writeIndex++] = values[(*removeIndex++).Index];
            }
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySortGroup
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> distinct(this long[] array)
        {
            if (array == null) return default(LeftArray<long>);
            if (array.Length <= 1) return new LeftArray<long> { Array = array, Length = array.Length };
            return new LeftArray<long> { Array = array, Length = Distinct(array, 0, array.Length) };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>结束位置</returns>
        internal static int Distinct(long[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (long* valueFixed = array)
            {
                long* write = valueFixed + startIndex, start = write + 1, end = write + count;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return (int)(write - valueFixed) + 1;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this long[] array, Func<long, valueType> getValue)
        {
            return array.isEmpty() ? NullValue<valueType>.Array : Distinct(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static valueType[] Distinct<valueType>(long[] array, Func<long, valueType> getValue, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + startIndex, end = start + count;
                long value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                valueType[] values = new valueType[valueCount];
                values[0] = getValue(value = *(start = valueFixed + startIndex));
                valueCount = 1;
                while (++start != end)
                {
                    if (*start != value) values[valueCount++] = getValue(value = *start);
                }
                return values;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> distinct<valueType>(this valueType[] array, Func<valueType, long> getValue)
        {
            long[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<long, int>[] sortGroupCount(this long[] array)
        {
            return array.isEmpty() ? NullValue<KeyValue<long, int>>.Array : SortGroupCount(array, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>分组数量</returns>
        internal static KeyValue<long, int>[] SortGroupCount(long[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (long* valueFixed = array)
            {
                long* start = valueFixed + startIndex, lastStart = start, end = start + count;
                long value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                KeyValue<long, int>[] values = new KeyValue<long, int>[valueCount];
                value = *(start = lastStart);
                valueCount = 0;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        values[valueCount++].Set(value, (int)(start - lastStart));
                        value = *start;
                        lastStart = start;
                    }
                }
                values[valueCount].Set(value, (int)(start - lastStart));
                return values;
            }
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> sortGroup<valueType>(this valueType[] array, Func<valueType, long> getValue)
        {
            return array.isEmpty() ? default(LeftArray<SubArray<valueType>>) : SortGroup(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static LeftArray<SubArray<valueType>> SortGroup<valueType>(this valueType[] array, Func<valueType, long> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            SubArray<valueType>[] values = new SubArray<valueType>[sortArray.Length];
            long key = getValue(sortArray[0]);
            int valueStartIndex = 0, valueIndex = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                long nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    values[valueIndex++].Set(sortArray, valueStartIndex, index - valueStartIndex);
                    key = nextKey;
                    valueStartIndex = index;
                }
            }
            values[valueIndex++].Set(sortArray, valueStartIndex, sortArray.Length - valueStartIndex);
            return new LeftArray<SubArray<valueType>> { Array = values, Length = valueIndex };
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int sortGroupCount<valueType>(this valueType[] array, Func<valueType, long> getValue)
        {
            return array.isEmpty() ? 0 : SortGroupCount(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>数据排序分组数量</returns>
        internal static int SortGroupCount<valueType>(this valueType[] array, Func<valueType, long> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            long key = getValue(sortArray[0]);
            int valueCount = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                long nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    ++valueCount;
                    key = nextKey;
                }
            }
            return valueCount + 1;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySortGroup
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> distinct(this uint[] array)
        {
            if (array == null) return default(LeftArray<uint>);
            if (array.Length <= 1) return new LeftArray<uint> { Array = array, Length = array.Length };
            return new LeftArray<uint> { Array = array, Length = Distinct(array, 0, array.Length) };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>结束位置</returns>
        internal static int Distinct(uint[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (uint* valueFixed = array)
            {
                uint* write = valueFixed + startIndex, start = write + 1, end = write + count;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return (int)(write - valueFixed) + 1;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this uint[] array, Func<uint, valueType> getValue)
        {
            return array.isEmpty() ? NullValue<valueType>.Array : Distinct(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static valueType[] Distinct<valueType>(uint[] array, Func<uint, valueType> getValue, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + startIndex, end = start + count;
                uint value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                valueType[] values = new valueType[valueCount];
                values[0] = getValue(value = *(start = valueFixed + startIndex));
                valueCount = 1;
                while (++start != end)
                {
                    if (*start != value) values[valueCount++] = getValue(value = *start);
                }
                return values;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> distinct<valueType>(this valueType[] array, Func<valueType, uint> getValue)
        {
            uint[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<uint, int>[] sortGroupCount(this uint[] array)
        {
            return array.isEmpty() ? NullValue<KeyValue<uint, int>>.Array : SortGroupCount(array, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>分组数量</returns>
        internal static KeyValue<uint, int>[] SortGroupCount(uint[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (uint* valueFixed = array)
            {
                uint* start = valueFixed + startIndex, lastStart = start, end = start + count;
                uint value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                KeyValue<uint, int>[] values = new KeyValue<uint, int>[valueCount];
                value = *(start = lastStart);
                valueCount = 0;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        values[valueCount++].Set(value, (int)(start - lastStart));
                        value = *start;
                        lastStart = start;
                    }
                }
                values[valueCount].Set(value, (int)(start - lastStart));
                return values;
            }
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> sortGroup<valueType>(this valueType[] array, Func<valueType, uint> getValue)
        {
            return array.isEmpty() ? default(LeftArray<SubArray<valueType>>) : SortGroup(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static LeftArray<SubArray<valueType>> SortGroup<valueType>(this valueType[] array, Func<valueType, uint> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            SubArray<valueType>[] values = new SubArray<valueType>[sortArray.Length];
            uint key = getValue(sortArray[0]);
            int valueStartIndex = 0, valueIndex = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                uint nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    values[valueIndex++].Set(sortArray, valueStartIndex, index - valueStartIndex);
                    key = nextKey;
                    valueStartIndex = index;
                }
            }
            values[valueIndex++].Set(sortArray, valueStartIndex, sortArray.Length - valueStartIndex);
            return new LeftArray<SubArray<valueType>> { Array = values, Length = valueIndex };
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int sortGroupCount<valueType>(this valueType[] array, Func<valueType, uint> getValue)
        {
            return array.isEmpty() ? 0 : SortGroupCount(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>数据排序分组数量</returns>
        internal static int SortGroupCount<valueType>(this valueType[] array, Func<valueType, uint> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            uint key = getValue(sortArray[0]);
            int valueCount = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                uint nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    ++valueCount;
                    key = nextKey;
                }
            }
            return valueCount + 1;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySortGroup
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> distinct(this int[] array)
        {
            if (array == null) return default(LeftArray<int>);
            if (array.Length <= 1) return new LeftArray<int> { Array = array, Length = array.Length };
            return new LeftArray<int> { Array = array, Length = Distinct(array, 0, array.Length) };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>结束位置</returns>
        internal static int Distinct(int[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (int* valueFixed = array)
            {
                int* write = valueFixed + startIndex, start = write + 1, end = write + count;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return (int)(write - valueFixed) + 1;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this int[] array, Func<int, valueType> getValue)
        {
            return array.isEmpty() ? NullValue<valueType>.Array : Distinct(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static valueType[] Distinct<valueType>(int[] array, Func<int, valueType> getValue, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + startIndex, end = start + count;
                int value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                valueType[] values = new valueType[valueCount];
                values[0] = getValue(value = *(start = valueFixed + startIndex));
                valueCount = 1;
                while (++start != end)
                {
                    if (*start != value) values[valueCount++] = getValue(value = *start);
                }
                return values;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> distinct<valueType>(this valueType[] array, Func<valueType, int> getValue)
        {
            int[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<int, int>[] sortGroupCount(this int[] array)
        {
            return array.isEmpty() ? NullValue<KeyValue<int, int>>.Array : SortGroupCount(array, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>分组数量</returns>
        internal static KeyValue<int, int>[] SortGroupCount(int[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (int* valueFixed = array)
            {
                int* start = valueFixed + startIndex, lastStart = start, end = start + count;
                int value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                KeyValue<int, int>[] values = new KeyValue<int, int>[valueCount];
                value = *(start = lastStart);
                valueCount = 0;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        values[valueCount++].Set(value, (int)(start - lastStart));
                        value = *start;
                        lastStart = start;
                    }
                }
                values[valueCount].Set(value, (int)(start - lastStart));
                return values;
            }
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> sortGroup<valueType>(this valueType[] array, Func<valueType, int> getValue)
        {
            return array.isEmpty() ? default(LeftArray<SubArray<valueType>>) : SortGroup(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static LeftArray<SubArray<valueType>> SortGroup<valueType>(this valueType[] array, Func<valueType, int> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            SubArray<valueType>[] values = new SubArray<valueType>[sortArray.Length];
            int key = getValue(sortArray[0]);
            int valueStartIndex = 0, valueIndex = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                int nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    values[valueIndex++].Set(sortArray, valueStartIndex, index - valueStartIndex);
                    key = nextKey;
                    valueStartIndex = index;
                }
            }
            values[valueIndex++].Set(sortArray, valueStartIndex, sortArray.Length - valueStartIndex);
            return new LeftArray<SubArray<valueType>> { Array = values, Length = valueIndex };
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int sortGroupCount<valueType>(this valueType[] array, Func<valueType, int> getValue)
        {
            return array.isEmpty() ? 0 : SortGroupCount(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>数据排序分组数量</returns>
        internal static int SortGroupCount<valueType>(this valueType[] array, Func<valueType, int> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            int key = getValue(sortArray[0]);
            int valueCount = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                int nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    ++valueCount;
                    key = nextKey;
                }
            }
            return valueCount + 1;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组扩展操作
    /// </summary>
    public static unsafe partial class FixedArraySortGroup
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> distinct(this DateTime[] array)
        {
            if (array == null) return default(LeftArray<DateTime>);
            if (array.Length <= 1) return new LeftArray<DateTime> { Array = array, Length = array.Length };
            return new LeftArray<DateTime> { Array = array, Length = Distinct(array, 0, array.Length) };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>结束位置</returns>
        internal static int Distinct(DateTime[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* write = valueFixed + startIndex, start = write + 1, end = write + count;
                do
                {
                    if (*start != *write) *++write = *start;
                }
                while (++start != end);
                return (int)(write - valueFixed) + 1;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this DateTime[] array, Func<DateTime, valueType> getValue)
        {
            return array.isEmpty() ? NullValue<valueType>.Array : Distinct(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static valueType[] Distinct<valueType>(DateTime[] array, Func<DateTime, valueType> getValue, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + startIndex, end = start + count;
                DateTime value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                valueType[] values = new valueType[valueCount];
                values[0] = getValue(value = *(start = valueFixed + startIndex));
                valueCount = 1;
                while (++start != end)
                {
                    if (*start != value) values[valueCount++] = getValue(value = *start);
                }
                return values;
            }
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> distinct<valueType>(this valueType[] array, Func<valueType, DateTime> getValue)
        {
            DateTime[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<DateTime, int>[] sortGroupCount(this DateTime[] array)
        {
            return array.isEmpty() ? NullValue<KeyValue<DateTime, int>>.Array : SortGroupCount(array, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>分组数量</returns>
        internal static KeyValue<DateTime, int>[] SortGroupCount(DateTime[] array, int startIndex, int count)
        {
            array.sort(startIndex, count);
            fixed (DateTime* valueFixed = array)
            {
                DateTime* start = valueFixed + startIndex, lastStart = start, end = start + count;
                DateTime value = *start;
                int valueCount = 1;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        ++valueCount;
                        value = *start;
                    }
                }
                KeyValue<DateTime, int>[] values = new KeyValue<DateTime, int>[valueCount];
                value = *(start = lastStart);
                valueCount = 0;
                while (++start != end)
                {
                    if (*start != value)
                    {
                        values[valueCount++].Set(value, (int)(start - lastStart));
                        value = *start;
                        lastStart = start;
                    }
                }
                values[valueCount].Set(value, (int)(start - lastStart));
                return values;
            }
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> sortGroup<valueType>(this valueType[] array, Func<valueType, DateTime> getValue)
        {
            return array.isEmpty() ? default(LeftArray<SubArray<valueType>>) : SortGroup(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>目标数据集合</returns>
        internal static LeftArray<SubArray<valueType>> SortGroup<valueType>(this valueType[] array, Func<valueType, DateTime> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            SubArray<valueType>[] values = new SubArray<valueType>[sortArray.Length];
            DateTime key = getValue(sortArray[0]);
            int valueStartIndex = 0, valueIndex = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                DateTime nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    values[valueIndex++].Set(sortArray, valueStartIndex, index - valueStartIndex);
                    key = nextKey;
                    valueStartIndex = index;
                }
            }
            values[valueIndex++].Set(sortArray, valueStartIndex, sortArray.Length - valueStartIndex);
            return new LeftArray<SubArray<valueType>> { Array = values, Length = valueIndex };
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>数据排序分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int sortGroupCount<valueType>(this valueType[] array, Func<valueType, DateTime> getValue)
        {
            return array.isEmpty() ? 0 : SortGroupCount(array, getValue, 0, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">数据数量</param>
        /// <returns>数据排序分组数量</returns>
        internal static int SortGroupCount<valueType>(this valueType[] array, Func<valueType, DateTime> getValue, int startIndex, int count)
        {
            valueType[] sortArray = array.getSort(getValue, startIndex, count);
            DateTime key = getValue(sortArray[0]);
            int valueCount = 0;
            for (int index = 1; index != sortArray.Length; ++index)
            {
                DateTime nextKey = getValue(sortArray[index]);
                if (key != nextKey)
                {
                    ++valueCount;
                    key = nextKey;
                }
            }
            return valueCount + 1;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getReverse(this LeftArray<long> array)
        {
            if (array.Length == 0) return NullValue<long>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> reverse(this LeftArray<long> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<long> array, long value)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public static long firstOrDefault(this LeftArray<long> array, Func<long, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<long> replaceFirst(this LeftArray<long> array, long value, Func<long, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<long> find(this LeftArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (long* valueFixed = array.Array)
            {
                long* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<long> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> getFind(this LeftArray<long> array, Func<long, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<long>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static long[] getFindArray(this LeftArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return NullValue<long>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static long[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, long> getValue)
        {
            if (subArray.Length == 0) return NullValue<long>.Array;
            valueType[] array = subArray.Array;
            long[] newValues = new long[subArray.Length];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<long> array, Func<long, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (long* arrayFixed = array.Array)
            {
                long* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<long> each(this LeftArray<long> array, Action<long> method)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    for (long* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<long> array, out long value)
        {
            if (array.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long Max(this LeftArray<long> array, long nullValue)
        {
            long value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                long nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            long maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                long nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<long> array, out long value)
        {
            if (array.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long Min(this LeftArray<long> array, long nullValue)
        {
            long value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                long nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            long minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                long nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getReverse(this LeftArray<uint> array)
        {
            if (array.Length == 0) return NullValue<uint>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> reverse(this LeftArray<uint> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<uint> array, uint value)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public static uint firstOrDefault(this LeftArray<uint> array, Func<uint, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<uint> replaceFirst(this LeftArray<uint> array, uint value, Func<uint, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<uint> find(this LeftArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (uint* valueFixed = array.Array)
            {
                uint* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<uint> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> getFind(this LeftArray<uint> array, Func<uint, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<uint>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static uint[] getFindArray(this LeftArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return NullValue<uint>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static uint[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, uint> getValue)
        {
            if (subArray.Length == 0) return NullValue<uint>.Array;
            valueType[] array = subArray.Array;
            uint[] newValues = new uint[subArray.Length];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<uint> array, Func<uint, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (uint* arrayFixed = array.Array)
            {
                uint* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<uint> each(this LeftArray<uint> array, Action<uint> method)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    for (uint* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<uint> array, out uint value)
        {
            if (array.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint Max(this LeftArray<uint> array, uint nullValue)
        {
            uint value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                uint nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            uint maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                uint nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<uint> array, out uint value)
        {
            if (array.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint Min(this LeftArray<uint> array, uint nullValue)
        {
            uint value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                uint nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            uint minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                uint nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getReverse(this LeftArray<int> array)
        {
            if (array.Length == 0) return NullValue<int>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> reverse(this LeftArray<int> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<int> array, int value)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public static int firstOrDefault(this LeftArray<int> array, Func<int, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<int> replaceFirst(this LeftArray<int> array, int value, Func<int, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<int> find(this LeftArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (int* valueFixed = array.Array)
            {
                int* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<int> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> getFind(this LeftArray<int> array, Func<int, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<int>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static int[] getFindArray(this LeftArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return NullValue<int>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static int[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, int> getValue)
        {
            if (subArray.Length == 0) return NullValue<int>.Array;
            valueType[] array = subArray.Array;
            int[] newValues = new int[subArray.Length];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<int> array, Func<int, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (int* arrayFixed = array.Array)
            {
                int* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<int> each(this LeftArray<int> array, Action<int> method)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    for (int* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<int> array, out int value)
        {
            if (array.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int Max(this LeftArray<int> array, int nullValue)
        {
            int value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                int nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                int nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<int> array, out int value)
        {
            if (array.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int Min(this LeftArray<int> array, int nullValue)
        {
            int value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                int nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                int nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] getReverse(this LeftArray<ushort> array)
        {
            if (array.Length == 0) return NullValue<ushort>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ushort> reverse(this LeftArray<ushort> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<ushort> array, ushort value)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public static ushort firstOrDefault(this LeftArray<ushort> array, Func<ushort, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<ushort> replaceFirst(this LeftArray<ushort> array, ushort value, Func<ushort, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<ushort> find(this LeftArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<ushort> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ushort> getFind(this LeftArray<ushort> array, Func<ushort, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<ushort>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static ushort[] getFindArray(this LeftArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return NullValue<ushort>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static ushort[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, ushort> getValue)
        {
            if (subArray.Length == 0) return NullValue<ushort>.Array;
            valueType[] array = subArray.Array;
            ushort[] newValues = new ushort[subArray.Length];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<ushort> array, Func<ushort, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (ushort* arrayFixed = array.Array)
            {
                ushort* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<ushort> each(this LeftArray<ushort> array, Action<ushort> method)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    for (ushort* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<ushort> array, out ushort value)
        {
            if (array.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort Max(this LeftArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                ushort nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            ushort maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                ushort nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<ushort> array, out ushort value)
        {
            if (array.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort Min(this LeftArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                ushort nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            ushort minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                ushort nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] getReverse(this LeftArray<short> array)
        {
            if (array.Length == 0) return NullValue<short>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<short> reverse(this LeftArray<short> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<short> array, short value)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public static short firstOrDefault(this LeftArray<short> array, Func<short, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<short> replaceFirst(this LeftArray<short> array, short value, Func<short, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<short> find(this LeftArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (short* valueFixed = array.Array)
            {
                short* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<short> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<short> getFind(this LeftArray<short> array, Func<short, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<short>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static short[] getFindArray(this LeftArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return NullValue<short>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static short[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, short> getValue)
        {
            if (subArray.Length == 0) return NullValue<short>.Array;
            valueType[] array = subArray.Array;
            short[] newValues = new short[subArray.Length];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<short> array, Func<short, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (short* arrayFixed = array.Array)
            {
                short* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<short> each(this LeftArray<short> array, Action<short> method)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    for (short* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<short> array, out short value)
        {
            if (array.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short Max(this LeftArray<short> array, short nullValue)
        {
            short value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                short nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            short maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                short nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<short> array, out short value)
        {
            if (array.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short Min(this LeftArray<short> array, short nullValue)
        {
            short value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                short nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            short minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                short nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] getReverse(this LeftArray<byte> array)
        {
            if (array.Length == 0) return NullValue<byte>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<byte> reverse(this LeftArray<byte> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<byte> array, byte value)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public static byte firstOrDefault(this LeftArray<byte> array, Func<byte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<byte> replaceFirst(this LeftArray<byte> array, byte value, Func<byte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<byte> find(this LeftArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (byte* valueFixed = array.Array)
            {
                byte* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<byte> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<byte> getFind(this LeftArray<byte> array, Func<byte, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<byte>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static byte[] getFindArray(this LeftArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return NullValue<byte>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static byte[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, byte> getValue)
        {
            if (subArray.Length == 0) return NullValue<byte>.Array;
            valueType[] array = subArray.Array;
            byte[] newValues = new byte[subArray.Length];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<byte> array, Func<byte, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (byte* arrayFixed = array.Array)
            {
                byte* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<byte> each(this LeftArray<byte> array, Action<byte> method)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    for (byte* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<byte> array, out byte value)
        {
            if (array.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte Max(this LeftArray<byte> array, byte nullValue)
        {
            byte value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                byte nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            byte maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                byte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<byte> array, out byte value)
        {
            if (array.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte Min(this LeftArray<byte> array, byte nullValue)
        {
            byte value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                byte nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            byte minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                byte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] getReverse(this LeftArray<sbyte> array)
        {
            if (array.Length == 0) return NullValue<sbyte>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<sbyte> reverse(this LeftArray<sbyte> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<sbyte> array, sbyte value)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public static sbyte firstOrDefault(this LeftArray<sbyte> array, Func<sbyte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<sbyte> replaceFirst(this LeftArray<sbyte> array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<sbyte> find(this LeftArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<sbyte> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<sbyte> getFind(this LeftArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<sbyte>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static sbyte[] getFindArray(this LeftArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return NullValue<sbyte>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static sbyte[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, sbyte> getValue)
        {
            if (subArray.Length == 0) return NullValue<sbyte>.Array;
            valueType[] array = subArray.Array;
            sbyte[] newValues = new sbyte[subArray.Length];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<sbyte> array, Func<sbyte, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (sbyte* arrayFixed = array.Array)
            {
                sbyte* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<sbyte> each(this LeftArray<sbyte> array, Action<sbyte> method)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    for (sbyte* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<sbyte> array, out sbyte value)
        {
            if (array.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte Max(this LeftArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                sbyte nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            sbyte maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                sbyte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<sbyte> array, out sbyte value)
        {
            if (array.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte Min(this LeftArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                sbyte nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            sbyte minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                sbyte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getReverse(this LeftArray<double> array)
        {
            if (array.Length == 0) return NullValue<double>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> reverse(this LeftArray<double> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<double> array, double value)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public static double firstOrDefault(this LeftArray<double> array, Func<double, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<double> replaceFirst(this LeftArray<double> array, double value, Func<double, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<double> find(this LeftArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (double* valueFixed = array.Array)
            {
                double* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<double> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> getFind(this LeftArray<double> array, Func<double, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<double>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static double[] getFindArray(this LeftArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return NullValue<double>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static double[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, double> getValue)
        {
            if (subArray.Length == 0) return NullValue<double>.Array;
            valueType[] array = subArray.Array;
            double[] newValues = new double[subArray.Length];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<double> array, Func<double, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (double* arrayFixed = array.Array)
            {
                double* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<double> each(this LeftArray<double> array, Action<double> method)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    for (double* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<double> array, out double value)
        {
            if (array.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double Max(this LeftArray<double> array, double nullValue)
        {
            double value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                double nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            double maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                double nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<double> array, out double value)
        {
            if (array.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double Min(this LeftArray<double> array, double nullValue)
        {
            double value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                double nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            double minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                double nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getReverse(this LeftArray<float> array)
        {
            if (array.Length == 0) return NullValue<float>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> reverse(this LeftArray<float> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<float> array, float value)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public static float firstOrDefault(this LeftArray<float> array, Func<float, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<float> replaceFirst(this LeftArray<float> array, float value, Func<float, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<float> find(this LeftArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (float* valueFixed = array.Array)
            {
                float* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<float> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> getFind(this LeftArray<float> array, Func<float, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<float>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static float[] getFindArray(this LeftArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return NullValue<float>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static float[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, float> getValue)
        {
            if (subArray.Length == 0) return NullValue<float>.Array;
            valueType[] array = subArray.Array;
            float[] newValues = new float[subArray.Length];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<float> array, Func<float, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (float* arrayFixed = array.Array)
            {
                float* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<float> each(this LeftArray<float> array, Action<float> method)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    for (float* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<float> array, out float value)
        {
            if (array.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float Max(this LeftArray<float> array, float nullValue)
        {
            float value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                float nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            float maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                float nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<float> array, out float value)
        {
            if (array.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float Min(this LeftArray<float> array, float nullValue)
        {
            float value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                float nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            float minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                float nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] getReverse(this LeftArray<char> array)
        {
            if (array.Length == 0) return NullValue<char>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<char> reverse(this LeftArray<char> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<char> array, char value)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(char)</returns>
        public static char firstOrDefault(this LeftArray<char> array, Func<char, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(char);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<char> replaceFirst(this LeftArray<char> array, char value, Func<char, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<char> find(this LeftArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (char* valueFixed = array.Array)
            {
                char* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<char> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<char> getFind(this LeftArray<char> array, Func<char, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<char>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static char[] getFindArray(this LeftArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return NullValue<char>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static char[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, char> getValue)
        {
            if (subArray.Length == 0) return NullValue<char>.Array;
            valueType[] array = subArray.Array;
            char[] newValues = new char[subArray.Length];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<char> array, Func<char, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (char* arrayFixed = array.Array)
            {
                char* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<char> each(this LeftArray<char> array, Action<char> method)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    for (char* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<char> array, out char value)
        {
            if (array.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char Max(this LeftArray<char> array, char nullValue)
        {
            char value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, char> getKey, out char value)
        {
            if (subArray.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                char nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, char> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            char maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                char nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<char> array, out char value)
        {
            if (array.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char Min(this LeftArray<char> array, char nullValue)
        {
            char value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, char> getKey, out char value)
        {
            if (subArray.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                char nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, char> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            char minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                char nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class LeftArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getReverse(this LeftArray<DateTime> array)
        {
            if (array.Length == 0) return NullValue<DateTime>.Array;
            return FixedArray.GetReverse(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> reverse(this LeftArray<DateTime> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<DateTime> array, DateTime value)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* index = FixedArray.IndexOf(valueFixed, array.Length, value);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this LeftArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* index = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public static DateTime firstOrDefault(this LeftArray<DateTime> array, Func<DateTime, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = FixedArray.IndexOf(valueFixed + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this LeftArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static LeftArray<DateTime> replaceFirst(this LeftArray<DateTime> array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = FixedArray.IndexOf(valueFixed, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static LeftArray<DateTime> find(this LeftArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* write = valueFixed, start = valueFixed, end = valueFixed + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new LeftArray<DateTime> { Array = array.Array, Length = (int)(write - valueFixed) };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> getFind(this LeftArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<DateTime>) : FixedArray.GetFind(array.Array, 0, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static DateTime[] getFindArray(this LeftArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return NullValue<DateTime>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = AutoCSer.UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, 0, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static DateTime[] getArray<valueType>(this LeftArray<valueType> subArray, Func<valueType, DateTime> getValue)
        {
            if (subArray.Length == 0) return NullValue<DateTime>.Array;
            valueType[] array = subArray.Array;
            DateTime[] newValues = new DateTime[subArray.Length];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                int index = 0;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != subArray.Length);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this LeftArray<DateTime> array, Func<DateTime, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (DateTime* arrayFixed = array.Array)
            {
                DateTime* start = arrayFixed, end = arrayFixed + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static LeftArray<DateTime> each(this LeftArray<DateTime> array, Action<DateTime> method)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    for (DateTime* start = valueFixed, end = valueFixed + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this LeftArray<DateTime> array, out DateTime value)
        {
            if (array.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime Max(this LeftArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                DateTime nextKey = getKey(array[--index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime MaxKey<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this LeftArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            DateTime maxKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                DateTime nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this LeftArray<DateTime> array, out DateTime value)
        {
            if (array.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed, end = valueFixed + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime Min(this LeftArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this LeftArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Length - 1;
            value = getKey(array[index]);
            while (index != 0)
            {
                DateTime nextKey = getKey(array[--index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime MinKey<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this LeftArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            DateTime minKey = getKey(value = array[0]);
            for (int index = 1; index != subArray.Length; ++index)
            {
                valueType nextValue = array[index];
                DateTime nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, ulong> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, ulong> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> RangeSortDesc(this LeftArray<ulong> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<ulong>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetRangeSortDesc(this LeftArray<ulong> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<ulong>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> PageSortDesc(this LeftArray<ulong> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetPageSortDesc(this LeftArray<ulong> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSort(this LeftArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSort(this LeftArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> PageSort(this LeftArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetPageSort(this LeftArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSortDesc(this LeftArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSortDesc(this LeftArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> PageSortDesc(this LeftArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetPageSortDesc(this LeftArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSort(this LeftArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSort(this LeftArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> PageSort(this LeftArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetPageSort(this LeftArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSortDesc(this LeftArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSortDesc(this LeftArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> PageSortDesc(this LeftArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetPageSortDesc(this LeftArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSort(this LeftArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSort(this LeftArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> PageSort(this LeftArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetPageSort(this LeftArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSortDesc(this LeftArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSortDesc(this LeftArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> PageSortDesc(this LeftArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetPageSortDesc(this LeftArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSort(this LeftArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSort(this LeftArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> PageSort(this LeftArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetPageSort(this LeftArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSortDesc(this LeftArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSortDesc(this LeftArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> PageSortDesc(this LeftArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetPageSortDesc(this LeftArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSort(this LeftArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSort(this LeftArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> PageSort(this LeftArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetPageSort(this LeftArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSortDesc(this LeftArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSortDesc(this LeftArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> PageSortDesc(this LeftArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetPageSortDesc(this LeftArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSort(this LeftArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSort(this LeftArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> PageSort(this LeftArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetPageSort(this LeftArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSortDesc(this LeftArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSortDesc(this LeftArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, 0, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> PageSortDesc(this LeftArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetPageSortDesc(this LeftArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, 0, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> SortDesc(this LeftArray<double> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] GetSortDesc(this LeftArray<double> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, double> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, getKey, 0, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[0] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> Sort(this LeftArray<float> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] GetSort(this LeftArray<float> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array.Array, getKey, 0, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[0] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class LeftArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> SortDesc(this LeftArray<float> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] GetSortDesc(this LeftArray<float> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, 0, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, getKey, 0, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[0] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ulong> SortDesc(this LeftArray<ulong> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ulong[] GetSortDesc(this LeftArray<ulong> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, ulong> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> Sort(this LeftArray<long> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] GetSort(this LeftArray<long> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> SortDesc(this LeftArray<long> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] GetSortDesc(this LeftArray<long> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, long> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> Sort(this LeftArray<uint> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] GetSort(this LeftArray<uint> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> SortDesc(this LeftArray<uint> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] GetSortDesc(this LeftArray<uint> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, uint> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> Sort(this LeftArray<int> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] GetSort(this LeftArray<int> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> SortDesc(this LeftArray<int> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] GetSortDesc(this LeftArray<int> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, int> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> Sort(this LeftArray<DateTime> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] GetSort(this LeftArray<DateTime> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class LeftArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> SortDesc(this LeftArray<DateTime> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, 0, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] GetSortDesc(this LeftArray<DateTime> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, 0, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this LeftArray<valueType> array, Func<valueType, DateTime> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, 0, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    internal unsafe struct LongSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public long Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(long))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public void Set(long value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(LongSortIndex* indexFixed, valueType[] values, Func<valueType, long> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(LongSortIndex* indexFixed, valueType[] values, Func<valueType, long> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static valueType[] Create<valueType>(LongSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    internal unsafe struct UIntSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public uint Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(uint))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public void Set(uint value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(UIntSortIndex* indexFixed, valueType[] values, Func<valueType, uint> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(UIntSortIndex* indexFixed, valueType[] values, Func<valueType, uint> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static valueType[] Create<valueType>(UIntSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    internal unsafe struct IntSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public int Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(int))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public void Set(int value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(IntSortIndex* indexFixed, valueType[] values, Func<valueType, int> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(IntSortIndex* indexFixed, valueType[] values, Func<valueType, int> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static valueType[] Create<valueType>(IntSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    internal unsafe struct DoubleSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public double Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(double))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public void Set(double value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(DoubleSortIndex* indexFixed, valueType[] values, Func<valueType, double> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(DoubleSortIndex* indexFixed, valueType[] values, Func<valueType, double> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static valueType[] Create<valueType>(DoubleSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}

namespace AutoCSer.Algorithm
{
    /// <summary>
    /// 排序索引
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
    internal unsafe struct FloatSortIndex
    {
        /// <summary>
        /// 数值
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(0)]
        public float Value;
        /// <summary>
        /// 位置索引
        /// </summary>
        [System.Runtime.InteropServices.FieldOffset(sizeof(float))]
        public int Index;
        /// <summary>
        /// 设置排序索引
        /// </summary>
        /// <param name="value">数值</param>
        /// <param name="index">位置索引</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public void Set(float value, int index)
        {
            Value = value;
            Index = index;
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(FloatSortIndex* indexFixed, valueType[] values, Func<valueType, float> getValue)
        {
            int index = 0;
            foreach (valueType value in values) (*indexFixed++).Set(getValue(value), index++);
        }
        /// <summary>
        /// 根据数组获取排序索引
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="getValue">数据排序值获取器</param>
        /// <param name="startIndex">起始位置</param>
        /// <param name="count">排序数据数量</param>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static void Create<valueType>(FloatSortIndex* indexFixed, valueType[] values, Func<valueType, float> getValue, int startIndex, int count)
        {
            for (int endIndex = startIndex + count; startIndex != endIndex; (*indexFixed++).Set(getValue(values[startIndex]), startIndex++)) ;
        }
        /// <summary>
        /// 根据排序索引获取数组
        /// </summary>
        /// <typeparam name="valueType">数组类型</typeparam>
        /// <param name="indexFixed">排序索引数组</param>
        /// <param name="values">数组</param>
        /// <param name="count">排序数据数量</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        internal static valueType[] Create<valueType>(FloatSortIndex* indexFixed, valueType[] values, int count)
        {
            valueType[] newValues = new valueType[count];
            for (int index = 0; index != count; ++index) newValues[index] = values[(*indexFixed++).Index];
            return newValues;
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] getReverse(this SubArray<long> array)
        {
            if (array.Length == 0) return NullValue<long>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> reverse(this SubArray<long> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<long> array, long value)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(long)</returns>
        public static long firstOrDefault(this SubArray<long> array, Func<long, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(long);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<long> replaceFirst(this SubArray<long> array, long value, Func<long, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    long* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<long> find(this SubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (long* valueFixed = array.Array)
            {
                long* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<long> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> getFind(this SubArray<long> array, Func<long, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<long>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static long[] getFindArray(this SubArray<long> array, Func<long, bool> isValue)
        {
            if (array.Length == 0) return NullValue<long>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static long[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, long> getValue)
        {
            if (subArray.Length == 0) return NullValue<long>.Array;
            valueType[] array = subArray.Array;
            long[] newValues = new long[subArray.Length];
            fixed (long* newValueFixed = newValues)
            {
                long* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<long> array, Func<long, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (long* arrayFixed = array.Array)
            {
                long* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<long> each(this SubArray<long> array, Action<long> method)
        {
            if (array.Length != 0)
            {
                fixed (long* valueFixed = array.Array)
                {
                    for (long* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<long> array, out long value)
        {
            if (array.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long Max(this SubArray<long> array, long nullValue)
        {
            long value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                long nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            long maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                long nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<long> array, out long value)
        {
            if (array.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            fixed (long* valueFixed = array.Array)
            {
                long* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long Min(this SubArray<long> array, long nullValue)
        {
            long value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, long> getKey, out long value)
        {
            if (subArray.Length == 0)
            {
                value = long.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                long nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long MinKey<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, long nullValue)
        {
            long value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, long> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            long minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                long nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] getReverse(this SubArray<uint> array)
        {
            if (array.Length == 0) return NullValue<uint>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> reverse(this SubArray<uint> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<uint> array, uint value)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(uint)</returns>
        public static uint firstOrDefault(this SubArray<uint> array, Func<uint, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(uint);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<uint> replaceFirst(this SubArray<uint> array, uint value, Func<uint, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    uint* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<uint> find(this SubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (uint* valueFixed = array.Array)
            {
                uint* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<uint> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> getFind(this SubArray<uint> array, Func<uint, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<uint>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static uint[] getFindArray(this SubArray<uint> array, Func<uint, bool> isValue)
        {
            if (array.Length == 0) return NullValue<uint>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static uint[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, uint> getValue)
        {
            if (subArray.Length == 0) return NullValue<uint>.Array;
            valueType[] array = subArray.Array;
            uint[] newValues = new uint[subArray.Length];
            fixed (uint* newValueFixed = newValues)
            {
                uint* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<uint> array, Func<uint, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (uint* arrayFixed = array.Array)
            {
                uint* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<uint> each(this SubArray<uint> array, Action<uint> method)
        {
            if (array.Length != 0)
            {
                fixed (uint* valueFixed = array.Array)
                {
                    for (uint* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<uint> array, out uint value)
        {
            if (array.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint Max(this SubArray<uint> array, uint nullValue)
        {
            uint value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                uint nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            uint maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                uint nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<uint> array, out uint value)
        {
            if (array.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            fixed (uint* valueFixed = array.Array)
            {
                uint* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint Min(this SubArray<uint> array, uint nullValue)
        {
            uint value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, uint> getKey, out uint value)
        {
            if (subArray.Length == 0)
            {
                value = uint.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                uint nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint MinKey<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, uint nullValue)
        {
            uint value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, uint> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            uint minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                uint nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] getReverse(this SubArray<int> array)
        {
            if (array.Length == 0) return NullValue<int>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> reverse(this SubArray<int> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<int> array, int value)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(int)</returns>
        public static int firstOrDefault(this SubArray<int> array, Func<int, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(int);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<int> replaceFirst(this SubArray<int> array, int value, Func<int, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    int* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<int> find(this SubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (int* valueFixed = array.Array)
            {
                int* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<int> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> getFind(this SubArray<int> array, Func<int, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<int>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static int[] getFindArray(this SubArray<int> array, Func<int, bool> isValue)
        {
            if (array.Length == 0) return NullValue<int>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static int[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, int> getValue)
        {
            if (subArray.Length == 0) return NullValue<int>.Array;
            valueType[] array = subArray.Array;
            int[] newValues = new int[subArray.Length];
            fixed (int* newValueFixed = newValues)
            {
                int* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<int> array, Func<int, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (int* arrayFixed = array.Array)
            {
                int* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<int> each(this SubArray<int> array, Action<int> method)
        {
            if (array.Length != 0)
            {
                fixed (int* valueFixed = array.Array)
                {
                    for (int* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<int> array, out int value)
        {
            if (array.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int Max(this SubArray<int> array, int nullValue)
        {
            int value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                int nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            int maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                int nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<int> array, out int value)
        {
            if (array.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            fixed (int* valueFixed = array.Array)
            {
                int* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int Min(this SubArray<int> array, int nullValue)
        {
            int value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, int> getKey, out int value)
        {
            if (subArray.Length == 0)
            {
                value = int.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                int nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int MinKey<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int nullValue)
        {
            int value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, int> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            int minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                int nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort[] getReverse(this SubArray<ushort> array)
        {
            if (array.Length == 0) return NullValue<ushort>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ushort> reverse(this SubArray<ushort> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<ushort> array, ushort value)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(ushort)</returns>
        public static ushort firstOrDefault(this SubArray<ushort> array, Func<ushort, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(ushort);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<ushort> replaceFirst(this SubArray<ushort> array, ushort value, Func<ushort, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    ushort* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<ushort> find(this SubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<ushort> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<ushort> getFind(this SubArray<ushort> array, Func<ushort, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<ushort>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static ushort[] getFindArray(this SubArray<ushort> array, Func<ushort, bool> isValue)
        {
            if (array.Length == 0) return NullValue<ushort>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static ushort[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, ushort> getValue)
        {
            if (subArray.Length == 0) return NullValue<ushort>.Array;
            valueType[] array = subArray.Array;
            ushort[] newValues = new ushort[subArray.Length];
            fixed (ushort* newValueFixed = newValues)
            {
                ushort* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<ushort> array, Func<ushort, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (ushort* arrayFixed = array.Array)
            {
                ushort* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<ushort> each(this SubArray<ushort> array, Action<ushort> method)
        {
            if (array.Length != 0)
            {
                fixed (ushort* valueFixed = array.Array)
                {
                    for (ushort* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<ushort> array, out ushort value)
        {
            if (array.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort Max(this SubArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                ushort nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            ushort maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                ushort nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<ushort> array, out ushort value)
        {
            if (array.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            fixed (ushort* valueFixed = array.Array)
            {
                ushort* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort Min(this SubArray<ushort> array, ushort nullValue)
        {
            ushort value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, ushort> getKey, out ushort value)
        {
            if (subArray.Length == 0)
            {
                value = ushort.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                ushort nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ushort MinKey<valueType>(this SubArray<valueType> array, Func<valueType, ushort> getKey, ushort nullValue)
        {
            ushort value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, ushort> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            ushort minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                ushort nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, ushort> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short[] getReverse(this SubArray<short> array)
        {
            if (array.Length == 0) return NullValue<short>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<short> reverse(this SubArray<short> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<short> array, short value)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(short)</returns>
        public static short firstOrDefault(this SubArray<short> array, Func<short, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(short);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<short> replaceFirst(this SubArray<short> array, short value, Func<short, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    short* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<short> find(this SubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (short* valueFixed = array.Array)
            {
                short* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<short> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<short> getFind(this SubArray<short> array, Func<short, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<short>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static short[] getFindArray(this SubArray<short> array, Func<short, bool> isValue)
        {
            if (array.Length == 0) return NullValue<short>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static short[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, short> getValue)
        {
            if (subArray.Length == 0) return NullValue<short>.Array;
            valueType[] array = subArray.Array;
            short[] newValues = new short[subArray.Length];
            fixed (short* newValueFixed = newValues)
            {
                short* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<short> array, Func<short, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (short* arrayFixed = array.Array)
            {
                short* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<short> each(this SubArray<short> array, Action<short> method)
        {
            if (array.Length != 0)
            {
                fixed (short* valueFixed = array.Array)
                {
                    for (short* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<short> array, out short value)
        {
            if (array.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short Max(this SubArray<short> array, short nullValue)
        {
            short value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                short nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            short maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                short nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<short> array, out short value)
        {
            if (array.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            fixed (short* valueFixed = array.Array)
            {
                short* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short Min(this SubArray<short> array, short nullValue)
        {
            short value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, short> getKey, out short value)
        {
            if (subArray.Length == 0)
            {
                value = short.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                short nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static short MinKey<valueType>(this SubArray<valueType> array, Func<valueType, short> getKey, short nullValue)
        {
            short value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, short> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            short minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                short nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, short> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte[] getReverse(this SubArray<byte> array)
        {
            if (array.Length == 0) return NullValue<byte>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<byte> reverse(this SubArray<byte> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<byte> array, byte value)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(byte)</returns>
        public static byte firstOrDefault(this SubArray<byte> array, Func<byte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(byte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<byte> replaceFirst(this SubArray<byte> array, byte value, Func<byte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    byte* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<byte> find(this SubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (byte* valueFixed = array.Array)
            {
                byte* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<byte> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<byte> getFind(this SubArray<byte> array, Func<byte, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<byte>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static byte[] getFindArray(this SubArray<byte> array, Func<byte, bool> isValue)
        {
            if (array.Length == 0) return NullValue<byte>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static byte[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, byte> getValue)
        {
            if (subArray.Length == 0) return NullValue<byte>.Array;
            valueType[] array = subArray.Array;
            byte[] newValues = new byte[subArray.Length];
            fixed (byte* newValueFixed = newValues)
            {
                byte* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<byte> array, Func<byte, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (byte* arrayFixed = array.Array)
            {
                byte* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<byte> each(this SubArray<byte> array, Action<byte> method)
        {
            if (array.Length != 0)
            {
                fixed (byte* valueFixed = array.Array)
                {
                    for (byte* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<byte> array, out byte value)
        {
            if (array.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte Max(this SubArray<byte> array, byte nullValue)
        {
            byte value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                byte nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            byte maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                byte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<byte> array, out byte value)
        {
            if (array.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            fixed (byte* valueFixed = array.Array)
            {
                byte* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte Min(this SubArray<byte> array, byte nullValue)
        {
            byte value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, byte> getKey, out byte value)
        {
            if (subArray.Length == 0)
            {
                value = byte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                byte nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static byte MinKey<valueType>(this SubArray<valueType> array, Func<valueType, byte> getKey, byte nullValue)
        {
            byte value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, byte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            byte minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                byte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, byte> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte[] getReverse(this SubArray<sbyte> array)
        {
            if (array.Length == 0) return NullValue<sbyte>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<sbyte> reverse(this SubArray<sbyte> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<sbyte> array, sbyte value)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(sbyte)</returns>
        public static sbyte firstOrDefault(this SubArray<sbyte> array, Func<sbyte, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(sbyte);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<sbyte> replaceFirst(this SubArray<sbyte> array, sbyte value, Func<sbyte, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    sbyte* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<sbyte> find(this SubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<sbyte> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<sbyte> getFind(this SubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<sbyte>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static sbyte[] getFindArray(this SubArray<sbyte> array, Func<sbyte, bool> isValue)
        {
            if (array.Length == 0) return NullValue<sbyte>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static sbyte[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, sbyte> getValue)
        {
            if (subArray.Length == 0) return NullValue<sbyte>.Array;
            valueType[] array = subArray.Array;
            sbyte[] newValues = new sbyte[subArray.Length];
            fixed (sbyte* newValueFixed = newValues)
            {
                sbyte* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<sbyte> array, Func<sbyte, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (sbyte* arrayFixed = array.Array)
            {
                sbyte* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<sbyte> each(this SubArray<sbyte> array, Action<sbyte> method)
        {
            if (array.Length != 0)
            {
                fixed (sbyte* valueFixed = array.Array)
                {
                    for (sbyte* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<sbyte> array, out sbyte value)
        {
            if (array.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte Max(this SubArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                sbyte nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            sbyte maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                sbyte nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<sbyte> array, out sbyte value)
        {
            if (array.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            fixed (sbyte* valueFixed = array.Array)
            {
                sbyte* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte Min(this SubArray<sbyte> array, sbyte nullValue)
        {
            sbyte value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, sbyte> getKey, out sbyte value)
        {
            if (subArray.Length == 0)
            {
                value = sbyte.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                sbyte nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static sbyte MinKey<valueType>(this SubArray<valueType> array, Func<valueType, sbyte> getKey, sbyte nullValue)
        {
            sbyte value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, sbyte> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            sbyte minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                sbyte nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, sbyte> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] getReverse(this SubArray<double> array)
        {
            if (array.Length == 0) return NullValue<double>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> reverse(this SubArray<double> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<double> array, double value)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(double)</returns>
        public static double firstOrDefault(this SubArray<double> array, Func<double, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(double);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<double> replaceFirst(this SubArray<double> array, double value, Func<double, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    double* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<double> find(this SubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (double* valueFixed = array.Array)
            {
                double* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<double> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<double> getFind(this SubArray<double> array, Func<double, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<double>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static double[] getFindArray(this SubArray<double> array, Func<double, bool> isValue)
        {
            if (array.Length == 0) return NullValue<double>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static double[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, double> getValue)
        {
            if (subArray.Length == 0) return NullValue<double>.Array;
            valueType[] array = subArray.Array;
            double[] newValues = new double[subArray.Length];
            fixed (double* newValueFixed = newValues)
            {
                double* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<double> array, Func<double, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (double* arrayFixed = array.Array)
            {
                double* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<double> each(this SubArray<double> array, Action<double> method)
        {
            if (array.Length != 0)
            {
                fixed (double* valueFixed = array.Array)
                {
                    for (double* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<double> array, out double value)
        {
            if (array.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double Max(this SubArray<double> array, double nullValue)
        {
            double value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                double nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            double maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                double nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<double> array, out double value)
        {
            if (array.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            fixed (double* valueFixed = array.Array)
            {
                double* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double Min(this SubArray<double> array, double nullValue)
        {
            double value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, double> getKey, out double value)
        {
            if (subArray.Length == 0)
            {
                value = double.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                double nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double MinKey<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, double nullValue)
        {
            double value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, double> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            double minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                double nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] getReverse(this SubArray<float> array)
        {
            if (array.Length == 0) return NullValue<float>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> reverse(this SubArray<float> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<float> array, float value)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(float)</returns>
        public static float firstOrDefault(this SubArray<float> array, Func<float, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(float);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<float> replaceFirst(this SubArray<float> array, float value, Func<float, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    float* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<float> find(this SubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (float* valueFixed = array.Array)
            {
                float* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<float> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<float> getFind(this SubArray<float> array, Func<float, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<float>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static float[] getFindArray(this SubArray<float> array, Func<float, bool> isValue)
        {
            if (array.Length == 0) return NullValue<float>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static float[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, float> getValue)
        {
            if (subArray.Length == 0) return NullValue<float>.Array;
            valueType[] array = subArray.Array;
            float[] newValues = new float[subArray.Length];
            fixed (float* newValueFixed = newValues)
            {
                float* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<float> array, Func<float, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (float* arrayFixed = array.Array)
            {
                float* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<float> each(this SubArray<float> array, Action<float> method)
        {
            if (array.Length != 0)
            {
                fixed (float* valueFixed = array.Array)
                {
                    for (float* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<float> array, out float value)
        {
            if (array.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float Max(this SubArray<float> array, float nullValue)
        {
            float value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                float nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            float maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                float nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<float> array, out float value)
        {
            if (array.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            fixed (float* valueFixed = array.Array)
            {
                float* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float Min(this SubArray<float> array, float nullValue)
        {
            float value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, float> getKey, out float value)
        {
            if (subArray.Length == 0)
            {
                value = float.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                float nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float MinKey<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, float nullValue)
        {
            float value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, float> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            float minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                float nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char[] getReverse(this SubArray<char> array)
        {
            if (array.Length == 0) return NullValue<char>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<char> reverse(this SubArray<char> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<char> array, char value)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(char)</returns>
        public static char firstOrDefault(this SubArray<char> array, Func<char, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(char);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<char> replaceFirst(this SubArray<char> array, char value, Func<char, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    char* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<char> find(this SubArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (char* valueFixed = array.Array)
            {
                char* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<char> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<char> getFind(this SubArray<char> array, Func<char, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<char>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static char[] getFindArray(this SubArray<char> array, Func<char, bool> isValue)
        {
            if (array.Length == 0) return NullValue<char>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static char[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, char> getValue)
        {
            if (subArray.Length == 0) return NullValue<char>.Array;
            valueType[] array = subArray.Array;
            char[] newValues = new char[subArray.Length];
            fixed (char* newValueFixed = newValues)
            {
                char* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<char> array, Func<char, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (char* arrayFixed = array.Array)
            {
                char* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<char> each(this SubArray<char> array, Action<char> method)
        {
            if (array.Length != 0)
            {
                fixed (char* valueFixed = array.Array)
                {
                    for (char* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<char> array, out char value)
        {
            if (array.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char Max(this SubArray<char> array, char nullValue)
        {
            char value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, char> getKey, out char value)
        {
            if (subArray.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                char nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, char> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            char maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                char nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<char> array, out char value)
        {
            if (array.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            fixed (char* valueFixed = array.Array)
            {
                char* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char Min(this SubArray<char> array, char nullValue)
        {
            char value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, char> getKey, out char value)
        {
            if (subArray.Length == 0)
            {
                value = char.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                char nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static char MinKey<valueType>(this SubArray<valueType> array, Func<valueType, char> getKey, char nullValue)
        {
            char value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, char> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            char minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                char nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, char> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] getReverse(this SubArray<DateTime> array)
        {
            if (array.Length == 0) return NullValue<DateTime>.Array;
            return FixedArray.GetReverse(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 逆转数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <returns>翻转后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> reverse(this SubArray<DateTime> array)
        {
            if (array.Length > 1) FixedArray.Reverse(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">匹配数据</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<DateTime> array, DateTime value)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, value);
                    if (index != null) return (int)(index - start);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取匹配数据位置
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配位置,失败为-1</returns>
        public static int indexOf(this SubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* start = valueFixed + array.Start, index = FixedArray.IndexOf(start, array.Length, isValue);
                    if (index != null) return (int)(index - valueFixed);
                }
            }
            return -1;
        }
        /// <summary>
        /// 获取第一个匹配值
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <param name="index">起始位置</param>
        /// <returns>第一个匹配值,失败为default(DateTime)</returns>
        public static DateTime firstOrDefault(this SubArray<DateTime> array, Func<DateTime, bool> isValue, int index)
        {
            if ((uint)index < (uint)array.Length)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = FixedArray.IndexOf(valueFixed + array.Start + index, array.Length - index, isValue);
                    if (valueIndex != null) return *valueIndex;
                }
            }
            return default(DateTime);
        }
        /// <summary>
        /// 获取匹配数量
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数量</returns>
        public static int count(this SubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return 0;
            int value = 0;
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed + array.Start, end = start + array.Length;
                do
                {
                    if (isValue(*start)) ++value;
                }
                while (++start != end);
            }
            return value;
        }
        /// <summary>
        /// 替换数据
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="value">新值</param>
        /// <param name="isValue">数据匹配器</param>
        public static SubArray<DateTime> replaceFirst(this SubArray<DateTime> array, DateTime value, Func<DateTime, bool> isValue)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    DateTime* valueIndex = FixedArray.IndexOf(valueFixed + array.Start, array.Length, isValue);
                    if (valueIndex != null) *valueIndex = value;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        public static SubArray<DateTime> find(this SubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return array;
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* write = valueFixed + array.Start, start = write, end = write + array.Length;
                do
                {
                    if (isValue(*start)) *write++ = *start;
                }
                while (++start != end);
                return new SubArray<DateTime> { Array = array.Array, Start = array.Start, Length = (int)(write - valueFixed) - array.Start };
            }
        }
        /// <summary>
        /// 获取匹配集合
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> getFind(this SubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            return array.Length == 0 ? default(LeftArray<DateTime>) : FixedArray.GetFind(array.Array, array.Start, array.Length, isValue);
        }
        /// <summary>
        /// 获取匹配数组
        /// </summary>
        /// <param name="array">数组数据</param>
        /// <param name="isValue">数据匹配器</param>
        /// <returns>匹配数组</returns>
        public static DateTime[] getFindArray(this SubArray<DateTime> array, Func<DateTime, bool> isValue)
        {
            if (array.Length == 0) return NullValue<DateTime>.Array;
            int length = ((array.Length + 63) >> 6) << 3;
            UnmanagedPool pool = UnmanagedPool.GetDefaultPool(length);
            Pointer.Size data = pool.GetSize64(length);
            try
            {
                Memory.ClearUnsafe(data.ULong, length >> 3);
                return FixedArray.GetFindArray(array.Array, array.Start, array.Length, isValue, new MemoryMap(data.Data));
            }
            finally { pool.PushOnly(ref data); }
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static DateTime[] getArray<valueType>(this SubArray<valueType> subArray, Func<valueType, DateTime> getValue)
        {
            if (subArray.Length == 0) return NullValue<DateTime>.Array;
            valueType[] array = subArray.Array;
            DateTime[] newValues = new DateTime[subArray.Length];
            fixed (DateTime* newValueFixed = newValues)
            {
                DateTime* write = newValueFixed;
                int index = subArray.Start, endIndex = index + subArray.Length;
                do
                {
                    *write++ = getValue(array[index++]);
                }
                while (index != endIndex);
            }
            return newValues;
        }
        /// <summary>
        /// 数组类型转换
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数组</returns>
        public static valueType[] getArray<valueType>(this SubArray<DateTime> array, Func<DateTime, valueType> getValue)
        {
            if (array.Length == 0) return NullValue<valueType>.Array;
            valueType[] newValues = new valueType[array.Length];
            fixed (DateTime* arrayFixed = array.Array)
            {
                DateTime* start = arrayFixed + array.Start, end = start + array.Length;
                int index = 0;
                do
                {
                    newValues[index++] = getValue(*start);
                }
                while (++start != end);
            }
            return newValues;
        }
        /// <summary>
        /// 遍历foreach
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="method">调用函数</param>
        /// <returns>数据数组</returns>
        public static SubArray<DateTime> each(this SubArray<DateTime> array, Action<DateTime> method)
        {
            if (array.Length != 0)
            {
                fixed (DateTime* valueFixed = array.Array)
                {
                    for (DateTime* start = valueFixed + array.Start, end = start + array.Length; start != end; method(*start++)) ;
                }
            }
            return array;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max(this SubArray<DateTime> array, out DateTime value)
        {
            if (array.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start > value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime Max(this SubArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return Max(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool MaxKey<valueType>(this SubArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                DateTime nextKey = getKey(array[index]);
                if (nextKey > value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime MaxKey<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return MaxKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最大值</param>
        /// <returns>是否存在最大值</returns>
        public static bool Max<valueType>(this SubArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            DateTime maxKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                DateTime nextKey = getKey(nextValue);
                if (nextKey > maxKey)
                {
                    maxKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最大值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最大值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Max<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return Max(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min(this SubArray<DateTime> array, out DateTime value)
        {
            if (array.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            fixed (DateTime* valueFixed = array.Array)
            {
                DateTime* start = valueFixed + array.Start, end = start + array.Length;
                for (value = *start; ++start != end; )
                {
                    if (*start < value) value = *start;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime Min(this SubArray<DateTime> array, DateTime nullValue)
        {
            DateTime value;
            return Min(array, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool MinKey<valueType>(this SubArray<valueType> subArray, Func<valueType, DateTime> getKey, out DateTime value)
        {
            if (subArray.Length == 0)
            {
                value = DateTime.MinValue;
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            value = getKey(array[index]);
            while (++index != endIndex)
            {
                DateTime nextKey = getKey(array[index]);
                if (nextKey < value) value = nextKey;
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime MinKey<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, DateTime nullValue)
        {
            DateTime value;
            return MinKey(array, getKey, out value) ? value : nullValue;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="subArray">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="value">最小值</param>
        /// <returns>是否存在最小值</returns>
        public static bool Min<valueType>(this SubArray<valueType> subArray, Func<valueType, DateTime> getKey, out valueType value)
        {
            if (subArray.Length == 0)
            {
                value = default(valueType);
                return false;
            }
            valueType[] array = subArray.Array;
            int index = subArray.Start, endIndex = index + subArray.Length;
            DateTime minKey = getKey(value = array[index]);
            while (++index != endIndex)
            {
                valueType nextValue = array[index];
                DateTime nextKey = getKey(nextValue);
                if (nextKey < minKey)
                {
                    minKey = nextKey;
                    value = nextValue;
                }
            }
            return true;
        }
        /// <summary>
        /// 获取最小值
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getKey">数据获取器</param>
        /// <param name="nullValue">默认空值</param>
        /// <returns>最小值,失败返回默认空值</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType Min<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, valueType nullValue)
        {
            valueType value;
            return Min(array, getKey, out value) ? value : nullValue;
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, ulong> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, ulong> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> RangeSortDesc(this SubArray<ulong> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<ulong>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetRangeSortDesc(this SubArray<ulong> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<ulong>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, ulong> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, ulong> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> PageSortDesc(this SubArray<ulong> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> GetPageSortDesc(this SubArray<ulong> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSort(this SubArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSort(this SubArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> PageSort(this SubArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetPageSort(this SubArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, long> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> RangeSortDesc(this SubArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetRangeSortDesc(this SubArray<long> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<long>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, long> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> PageSortDesc(this SubArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> GetPageSortDesc(this SubArray<long> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSort(this SubArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSort(this SubArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> PageSort(this SubArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetPageSort(this SubArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> RangeSortDesc(this SubArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetRangeSortDesc(this SubArray<uint> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<uint>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, uint> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> PageSortDesc(this SubArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> GetPageSortDesc(this SubArray<uint> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSort(this SubArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSort(this SubArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> PageSort(this SubArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetPageSort(this SubArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, int> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> RangeSortDesc(this SubArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetRangeSortDesc(this SubArray<int> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<int>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, int> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> PageSortDesc(this SubArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> GetPageSortDesc(this SubArray<int> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSort(this SubArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSort(this SubArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> PageSort(this SubArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetPageSort(this SubArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, double> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> RangeSortDesc(this SubArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetRangeSortDesc(this SubArray<double> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<double>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, double> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> PageSortDesc(this SubArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> GetPageSortDesc(this SubArray<double> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSort(this SubArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSort(this SubArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> PageSort(this SubArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetPageSort(this SubArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, float> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> RangeSortDesc(this SubArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetRangeSortDesc(this SubArray<float> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<float>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, float> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> PageSortDesc(this SubArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> GetPageSortDesc(this SubArray<float> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSort<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSort(this SubArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSort(this SubArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSort<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSort<valueType, returnType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSort(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> PageSort(this SubArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetPageSort(this SubArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSort(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetPageSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">获取排序关键字委托</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <param name="getValue">获取返回数据</param>
        /// <param name="count">数据总量</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetPageSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int pageSize, int currentPage, Func<valueType, returnType> getValue, out int count)
        {
            PageCount page = new PageCount(count = array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, count, getKey, page.SkipCount, page.CurrentPageSize, getValue);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> RangeSortDesc(this SubArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.RangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetRangeSortDesc(this SubArray<DateTime> array, int skipCount, int getCount)
        {
            return array.Length == 0 ? default(SubArray<DateTime>) : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetRangeSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount);
        }
        /// <summary>
        /// 范围排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <typeparam name="returnType">返回数据类型</typeparam>
        /// <param name="array">数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <param name="skipCount">跳过记录数</param>
        /// <param name="getCount">获取记录数,小于0表示所有</param>
        /// <param name="getValue">获取返回数据</param>
        /// <returns>排序范围数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static returnType[] GetRangeSortDesc<valueType, returnType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey, int skipCount, int getCount, Func<valueType, returnType> getValue)
        {
            return array.Length == 0 ? NullValue<returnType>.Array : AutoCSer.Algorithm.FixedArrayQuickRangeSort.GetRangeSortDesc(array.Array, array.Start, array.Length, getKey, skipCount, getCount, getValue);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> PageSortDesc(this SubArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
        /// <summary>
        /// 分页排序
        /// </summary>
        /// <param name="array">数组子串</param>
        /// <param name="pageSize">分页尺寸</param>
        /// <param name="currentPage">页号</param>
        /// <returns>分页排序数据</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> GetPageSortDesc(this SubArray<DateTime> array, int pageSize, int currentPage)
        {
            PageCount page = new PageCount(array.Length, pageSize, currentPage);
            return AutoCSer.Algorithm.FixedArrayQuickRangeSort.UnsafeGetRangeSortDesc(array.Array, array.Start, array.Length, page.SkipCount, page.CurrentPageSize);
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<double> SortDesc(this SubArray<double> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static double[] GetSortDesc(this SubArray<double> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, double> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, getKey, array.Start, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[array.Start] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> Sort(this SubArray<float> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.Sort(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] GetSort(this SubArray<float> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSort(array.Array, getKey, array.Start, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[array.Start] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展
    /// </summary>
    public unsafe static partial class SubArray
    {
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<float> SortDesc(this SubArray<float> array)
        {
            if (array.Length > 1) AutoCSer.Algorithm.FixedArrayQuickSort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组排序
        /// </summary>
        /// <param name="array">待排序数组</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static float[] GetSortDesc(this SubArray<float> array)
        {
            return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, float> getKey)
        {
            if (array.Length > 1) return AutoCSer.Algorithm.FixedArrayQuickSort.GetSortDesc(array.Array, getKey, array.Start, array.Length);
            return array.Length == 0 ? NullValue<valueType>.Array : new valueType[] { array.Array[array.Start] };
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<ulong> SortDesc(this SubArray<ulong> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static ulong[] GetSortDesc(this SubArray<ulong> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, ulong> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> Sort(this SubArray<long> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] GetSort(this SubArray<long> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> SortDesc(this SubArray<long> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static long[] GetSortDesc(this SubArray<long> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, long> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> Sort(this SubArray<uint> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] GetSort(this SubArray<uint> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> SortDesc(this SubArray<uint> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static uint[] GetSortDesc(this SubArray<uint> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, uint> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> Sort(this SubArray<int> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] GetSort(this SubArray<int> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> SortDesc(this SubArray<int> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int[] GetSortDesc(this SubArray<int> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, int> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> Sort(this SubArray<DateTime> array)
        {
            if (array.Length > 1) FixedArraySort.Sort(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] GetSort(this SubArray<DateTime> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSort<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSort(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static partial class SubArray
    {
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的数组子串</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> SortDesc(this SubArray<DateTime> array)
        {
            if (array.Length > 1) FixedArraySort.SortDesc(array.Array, array.Start, array.Length);
            return array;
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <param name="array">待排序数组子串</param>
        /// <returns>排序后的新数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static DateTime[] GetSortDesc(this SubArray<DateTime> array)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, array.Start, array.Length) : array.GetArray();
        }
        /// <summary>
        /// 数组子串排序
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">待排序数组子串</param>
        /// <param name="getKey">排序键</param>
        /// <returns>排序后的数组</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] GetSortDesc<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getKey)
        {
            return array.Length > 1 ? FixedArraySort.GetSortDesc(array.Array, getKey, array.Start, array.Length) : array.GetArray();
        }
    }
}

namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<long> distinct(this SubArray<long> array)
        {
            if (array.Length <= 1) return array;
            return new SubArray<long> { Array = array.Array, Start = array.Start, Length = FixedArraySortGroup.Distinct(array.Array, array.Start, array.Length) - array.Start };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this SubArray<long> array, Func<long, valueType> getValue)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : FixedArraySortGroup.Distinct(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<long> distinct<valueType>(this SubArray<valueType> array, Func<valueType, long> getValue)
        {
            long[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<long, int>[] SortGroupCount(this SubArray<long> array)
        {
            return array.Length == 0 ? NullValue<KeyValue<long, int>>.Array : FixedArraySortGroup.SortGroupCount(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> SortGroup<valueType>(this SubArray<valueType> array, Func<valueType, long> getValue)
        {
            return array.Length == 0 ? default(LeftArray<SubArray<valueType>>) : FixedArraySortGroup.SortGroup(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int SortGroupCount<valueType>(this SubArray<valueType> array, Func<valueType, long> getValue)
        {
            return array.Length == 0 ? 0 : FixedArraySortGroup.SortGroupCount(array.Array, getValue, array.Start, array.Length);
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<uint> distinct(this SubArray<uint> array)
        {
            if (array.Length <= 1) return array;
            return new SubArray<uint> { Array = array.Array, Start = array.Start, Length = FixedArraySortGroup.Distinct(array.Array, array.Start, array.Length) - array.Start };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this SubArray<uint> array, Func<uint, valueType> getValue)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : FixedArraySortGroup.Distinct(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<uint> distinct<valueType>(this SubArray<valueType> array, Func<valueType, uint> getValue)
        {
            uint[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<uint, int>[] SortGroupCount(this SubArray<uint> array)
        {
            return array.Length == 0 ? NullValue<KeyValue<uint, int>>.Array : FixedArraySortGroup.SortGroupCount(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> SortGroup<valueType>(this SubArray<valueType> array, Func<valueType, uint> getValue)
        {
            return array.Length == 0 ? default(LeftArray<SubArray<valueType>>) : FixedArraySortGroup.SortGroup(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int SortGroupCount<valueType>(this SubArray<valueType> array, Func<valueType, uint> getValue)
        {
            return array.Length == 0 ? 0 : FixedArraySortGroup.SortGroupCount(array.Array, getValue, array.Start, array.Length);
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<int> distinct(this SubArray<int> array)
        {
            if (array.Length <= 1) return array;
            return new SubArray<int> { Array = array.Array, Start = array.Start, Length = FixedArraySortGroup.Distinct(array.Array, array.Start, array.Length) - array.Start };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this SubArray<int> array, Func<int, valueType> getValue)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : FixedArraySortGroup.Distinct(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<int> distinct<valueType>(this SubArray<valueType> array, Func<valueType, int> getValue)
        {
            int[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<int, int>[] SortGroupCount(this SubArray<int> array)
        {
            return array.Length == 0 ? NullValue<KeyValue<int, int>>.Array : FixedArraySortGroup.SortGroupCount(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> SortGroup<valueType>(this SubArray<valueType> array, Func<valueType, int> getValue)
        {
            return array.Length == 0 ? default(LeftArray<SubArray<valueType>>) : FixedArraySortGroup.SortGroup(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int SortGroupCount<valueType>(this SubArray<valueType> array, Func<valueType, int> getValue)
        {
            return array.Length == 0 ? 0 : FixedArraySortGroup.SortGroupCount(array.Array, getValue, array.Start, array.Length);
        }
    }
}
namespace AutoCSer.Extension
{
    /// <summary>
    /// 数组子串扩展操作
    /// </summary>
    public static unsafe partial class SubArray
    {
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static SubArray<DateTime> distinct(this SubArray<DateTime> array)
        {
            if (array.Length <= 1) return array;
            return new SubArray<DateTime> { Array = array.Array, Start = array.Start, Length = FixedArraySortGroup.Distinct(array.Array, array.Start, array.Length) - array.Start };
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static valueType[] distinct<valueType>(this SubArray<DateTime> array, Func<DateTime, valueType> getValue)
        {
            return array.Length == 0 ? NullValue<valueType>.Array : FixedArraySortGroup.Distinct(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据去重
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<DateTime> distinct<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            DateTime[] newValues = array.getArray(getValue);
            newValues.sort(0, newValues.Length);
            return newValues.distinct();
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <param name="array">数据数组</param>
        /// <returns>分组数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static KeyValue<DateTime, int>[] SortGroupCount(this SubArray<DateTime> array)
        {
            return array.Length == 0 ? NullValue<KeyValue<DateTime, int>>.Array : FixedArraySortGroup.SortGroupCount(array.Array, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static LeftArray<SubArray<valueType>> SortGroup<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            return array.Length == 0 ? default(LeftArray<SubArray<valueType>>) : FixedArraySortGroup.SortGroup(array.Array, getValue, array.Start, array.Length);
        }
        /// <summary>
        /// 数据排序分组数量
        /// </summary>
        /// <typeparam name="valueType">数据类型</typeparam>
        /// <param name="array">数据数组</param>
        /// <param name="getValue">数据获取器</param>
        /// <returns>目标数据集合数量</returns>
        [System.Runtime.CompilerServices.MethodImpl(AutoCSer.MethodImpl.AggressiveInlining)]
        public static int SortGroupCount<valueType>(this SubArray<valueType> array, Func<valueType, DateTime> getValue)
        {
            return array.Length == 0 ? 0 : FixedArraySortGroup.SortGroupCount(array.Array, getValue, array.Start, array.Length);
        }
    }
}
#endif